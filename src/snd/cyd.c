/*
Copyright (c) 2009-2011 Tero Lindeman (kometbomb)

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include "cyd.h"
#include "macros.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "math.h"

#ifndef STANDALONE_COMPILE

#include <../../../src/mused.h> //wasn't there
#include <../../../src/view.h> //wasn't there

#endif

#ifdef ENABLEAUDIODUMP
#include <time.h>
#endif

#include "cyddefs.h"
#include "cydwave.h"
#include "freqs.h"
#include "cydosc.h"
#include "music.h"

#ifndef USENATIVEAPIS
# ifndef NOSDL_MIXER
# include "SDL_mixer.h"
# endif
#else

# ifdef WIN32
# endif

#endif

//#define envspd(cyd,slope) (slope!=0?(((Uint64)0xff0000 / ((slope) * (slope) * 256 / (ENVELOPE_SCALE * ENVELOPE_SCALE))) * CYD_BASE_FREQ / cyd->sample_rate):((Uint64)0xff0000 * CYD_BASE_FREQ / cyd->sample_rate))

#ifndef STANDALONE_COMPILE

extern Mused mused;

#endif

Uint16 PulseTri_8580[8192] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3840,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1792,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1792,1792,7936,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,3840,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5888,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15104,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15616,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15872,0,0,0,0,0,0,0,16128,0,3072,7168,16128,7680,16128,16128,16128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3840,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1792,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2816,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2560,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24064,0,0,0,0,0,0,0,24320,0,0,0,24320,3072,24320,24320,24320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17152,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25856,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28160,0,0,0,0,0,0,0,28416,0,16384,16384,28416,16384,28416,28416,28416,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25344,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16384,24832,0,0,0,0,0,0,0,16384,0,0,0,16384,0,16384,16384,28672,0,0,16384,16384,16384,16384,16384,28672,16384,24576,24576,30464,24576,30464,30464,30464,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16384,0,0,0,0,0,0,16384,24576,0,16384,16384,24576,16384,24576,24576,30976,0,16384,16384,16384,16384,16384,16384,24576,16384,16384,16384,24576,24576,24576,24576,30720,16384,24576,24576,24576,24576,24576,24576,30720,24576,28672,28672,30720,28672,30976,31488,31488,24576,24576,24576,24576,24576,24576,24576,28672,24576,24576,24576,28672,24576,28672,28672,31744,24576,28672,28672,28672,28672,28672,28672,31744,28672,30720,30720,31744,30720,31744,31744,32000,28672,30720,30720,30720,30720,30720,30720,31744,30720,31744,31744,32256,31744,32256,32256,32256,31744,31744,31744,32256,32256,32512,32512,32512,32256,32512,32512,32512,32512,32512,32512,65280,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36608,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34560,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33536,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32768,36096,0,0,0,0,0,0,0,32768,0,0,0,32768,0,32768,32768,36352,0,0,0,32768,32768,32768,32768,36608,32768,32768,32768,40704,32768,40704,40704,40704,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32768,0,0,0,0,0,0,0,32768,0,0,0,32768,0,32768,32768,34560,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32768,0,0,0,0,0,0,0,32768,0,0,0,32768,32768,32768,32768,33536,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32768,0,0,0,0,0,32768,32768,32768,0,32768,32768,32768,32768,32768,32768,33024,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,33792,32768,32768,32768,32768,32768,32768,32768,34560,32768,32768,32768,34560,32768,36608,44800,44800,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32768,0,0,0,0,0,0,0,32768,0,0,0,32768,32768,32768,32768,32768,0,0,0,32768,0,0,32768,32768,0,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,33536,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,33024,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,40960,32768,32768,32768,32768,32768,32768,32768,40960,32768,32768,32768,40960,32768,41728,46848,46848,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,45312,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,45056,32768,32768,32768,32768,32768,32768,32768,45056,32768,40960,40960,45056,40960,47104,47360,47872,32768,32768,32768,32768,32768,32768,32768,40960,32768,32768,32768,40960,32768,40960,40960,47104,32768,40960,40960,40960,40960,40960,40960,47104,40960,45056,45056,47104,45056,48128,48128,48384,40960,45056,45056,45056,45056,47104,47104,48128,45056,47104,47104,48128,47104,48128,48640,48640,47104,48128,48128,48640,48128,48640,48640,48896,48640,48896,48896,48896,48896,48896,48896,48896,0,0,0,32768,0,0,0,32768,0,0,0,32768,0,0,0,32768,0,32768,32768,32768,32768,32768,32768,32768,0,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,33024,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,50944,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,49152,49920,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,49152,32768,32768,32768,32768,32768,32768,32768,49152,32768,32768,32768,49152,32768,49152,49152,49408,32768,32768,32768,32768,32768,32768,32768,49152,32768,32768,32768,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,50944,49152,49152,49152,50944,49152,52992,52992,52992,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,49152,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,49152,32768,32768,32768,32768,32768,32768,49152,49152,32768,49152,49152,49152,49152,49152,49152,49920,32768,32768,32768,32768,32768,32768,32768,49152,32768,32768,32768,49152,32768,49152,49152,49152,32768,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49408,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49408,50944,55040,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,53248,49152,49152,49152,49152,49152,49152,49152,53248,49152,49152,49152,53248,49152,53248,55296,56064,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,55296,49152,49152,49152,49152,49152,49152,49152,55296,49152,49152,49152,55296,53248,55296,55296,56576,49152,49152,49152,53248,49152,53248,53248,56320,53248,55296,55296,56320,55296,56320,56320,56832,55296,56320,56320,56832,56320,56832,56832,57088,56832,57088,57088,57088,57088,57088,57088,57088,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,58112,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,57344,49152,49152,49152,57344,49152,57344,57344,57600,49152,49152,49152,49152,49152,49152,49152,57344,49152,49152,49152,57344,57344,57344,57344,57344,49152,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57600,58112,59136,49152,49152,49152,49152,49152,49152,49152,57344,49152,49152,49152,57344,49152,57344,57344,57344,49152,49152,49152,57344,49152,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,60160,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,59392,57344,59392,59392,60672,57344,57344,57344,57344,57344,57344,57344,60416,57344,57344,57344,60416,59392,60416,60416,60928,59392,59392,59392,60416,60416,60928,60928,61184,60416,61184,61184,61184,61184,61184,61184,61184,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,61440,57344,57344,57344,57344,57344,57344,57344,61440,57344,57344,57344,61440,57344,61440,61440,61440,57344,57344,57344,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,62208,57344,57344,57344,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,62720,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,62464,62464,62976,61440,61440,61440,62464,61440,62464,62976,63232,62464,62976,62976,63232,63232,63232,63232,63232,61440,61440,61440,61440,61440,61440,61440,63488,61440,61440,61440,61440,61440,63488,63488,63488,61440,61440,61440,63488,61440,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63744,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,64000,63488,63488,63488,63488,63488,63488,63488,64256,63488,64000,64000,64256,64256,64256,64256,64256,63488,63488,63488,64512,63488,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64768,64512,64512,64512,64768,64768,64768,64768,64768,64512,64512,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65280,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,65024,64512,64512,64768,64768,64768,64768,64768,64512,64512,64512,64768,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,64512,63488,64512,63488,63488,63488,64256,64256,64256,64256,64256,64000,64000,63488,64256,63488,63488,63488,63488,63488,63488,63488,64000,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,63744,63488,63488,63488,63488,63488,63488,63488,63488,63488,63488,61440,63488,61440,61440,61440,63488,63488,63488,61440,61440,61440,61440,61440,63488,61440,61440,61440,61440,61440,61440,61440,63232,63232,63232,63232,63232,62976,62976,62464,63232,62976,62464,61440,62464,61440,61440,61440,62976,62464,62464,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,62720,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,57344,57344,57344,62208,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,61440,57344,57344,57344,61440,61440,61440,57344,61440,57344,57344,57344,61440,57344,57344,57344,57344,57344,57344,57344,61440,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,61184,61184,61184,61184,61184,61184,61184,60416,61184,60928,60928,60416,60416,59392,59392,59392,60928,60416,60416,59392,60416,57344,57344,57344,60416,57344,57344,57344,57344,57344,57344,57344,60672,59392,59392,57344,59392,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,60160,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,49152,57344,49152,49152,49152,57344,57344,57344,49152,57344,49152,49152,49152,57344,49152,49152,49152,49152,49152,49152,49152,59136,58112,57600,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,57344,49152,57344,57344,57344,57344,57344,49152,49152,49152,57344,49152,49152,49152,49152,49152,49152,49152,57600,57344,57344,49152,57344,49152,49152,49152,57344,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,58112,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,57088,57088,57088,57088,57088,57088,57088,56832,57088,56832,56832,56320,56832,56320,56320,55296,56832,56320,56320,55296,56320,55296,55296,53248,56320,53248,53248,49152,53248,49152,49152,49152,56576,55296,55296,53248,55296,49152,49152,49152,55296,49152,49152,49152,49152,49152,49152,49152,55296,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,56064,55296,53248,49152,53248,49152,49152,49152,53248,49152,49152,49152,49152,49152,49152,49152,53248,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,55040,50944,49408,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49408,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,32768,49152,49152,49152,32768,49152,32768,32768,32768,49152,32768,32768,32768,32768,32768,32768,32768,49920,49152,49152,49152,49152,49152,49152,32768,49152,49152,32768,32768,32768,32768,32768,32768,49152,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,49152,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,52992,52992,52992,49152,50944,49152,49152,49152,50944,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,49152,32768,32768,32768,49152,32768,32768,32768,32768,32768,32768,32768,49408,49152,49152,32768,49152,32768,32768,32768,49152,32768,32768,32768,32768,32768,32768,32768,49152,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,49920,49152,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,50944,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,33024,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,0,32768,32768,32768,32768,32768,32768,32768,0,32768,0,0,0,32768,0,0,0,32768,0,0,0,32768,0,0,0,48896,48896,48896,48896,48896,48896,48896,48640,48896,48640,48640,48128,48640,48128,48128,47104,48640,48640,48128,47104,48128,47104,47104,45056,48128,47104,47104,45056,45056,45056,45056,40960,48384,48128,48128,45056,47104,45056,45056,40960,47104,40960,40960,40960,40960,40960,40960,32768,47104,40960,40960,32768,40960,32768,32768,32768,40960,32768,32768,32768,32768,32768,32768,32768,47872,47360,47104,40960,45056,40960,40960,32768,45056,32768,32768,32768,32768,32768,32768,32768,45056,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,45312,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,46848,46848,41728,32768,40960,32768,32768,32768,40960,32768,32768,32768,32768,32768,32768,32768,40960,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,33024,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,33536,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,0,32768,32768,0,0,32768,0,0,0,32768,32768,32768,32768,32768,0,0,0,32768,0,0,0,0,0,0,0,32768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44800,44800,36608,32768,34560,32768,32768,32768,34560,32768,32768,32768,32768,32768,32768,32768,33792,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,32768,33024,32768,32768,32768,32768,32768,32768,0,32768,32768,32768,0,0,0,0,0,32768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33536,32768,32768,32768,32768,0,0,0,32768,0,0,0,0,0,0,0,32768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34560,32768,32768,0,32768,0,0,0,32768,0,0,0,0,0,0,0,32768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40704,40704,40704,32768,40704,32768,32768,32768,36608,32768,32768,32768,32768,0,0,0,36352,32768,32768,0,32768,0,0,0,32768,0,0,0,0,0,0,0,36096,32768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33536,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34560,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36608,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,65280,32512,32512,32512,32512,32512,32512,32256,32512,32512,32512,32256,32256,31744,31744,31744,32256,32256,32256,31744,32256,31744,31744,30720,31744,30720,30720,30720,30720,30720,30720,28672,32000,31744,31744,30720,31744,30720,30720,28672,31744,28672,28672,28672,28672,28672,28672,24576,31744,28672,28672,24576,28672,24576,24576,24576,28672,24576,24576,24576,24576,24576,24576,24576,31488,31488,30976,28672,30720,28672,28672,24576,30720,24576,24576,24576,24576,24576,24576,16384,30720,24576,24576,24576,24576,16384,16384,16384,24576,16384,16384,16384,16384,16384,16384,0,30976,24576,24576,16384,24576,16384,16384,0,24576,16384,0,0,0,0,0,0,16384,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30464,30464,30464,24576,30464,24576,24576,16384,28672,16384,16384,16384,16384,16384,0,0,28672,16384,16384,0,16384,0,0,0,16384,0,0,0,0,0,0,0,24832,16384,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25344,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28416,28416,28416,16384,28416,16384,16384,0,28416,0,0,0,0,0,0,0,28160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25856,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17152,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24320,24320,24320,3072,24320,0,0,0,24320,0,0,0,0,0,0,0,24064,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2560,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2816,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1792,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3840,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16128,16128,16128,7680,16128,7168,3072,0,16128,0,0,0,0,0,0,0,15872,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15616,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15104,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5888,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3840,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7936,1792,1792,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1792,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3840,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,256,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,768,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

static inline int two_pow(int a, int x) //to avoid using much slower pow()
{
	int temp = a;
	
	a = 1;
	
	for(int i = 0; i < x; ++i)
	{
		a *= temp;
	}
	
	return a;
}

// used lfsr-generator <http://lfsr-generator.sourceforge.net/> for this: 

inline static void shift_lfsr(Uint32 *v, int tap_0, int tap_1)
{
  typedef unsigned int T;
  const T zero = (T)(0);
  const T lsb = zero + (T)(1);
  const T feedback = (
    (lsb << (tap_0)) ^
    (lsb << (tap_1))
  );
  *v = (*v >> 1) ^ ((zero - (*v & lsb)) & feedback);
}


static void cyd_init_channel(CydEngine *cyd, CydChannel *chn)
{
	memset(chn, 0, sizeof(*chn));
	chn->pw = 0x400;
	cyd_set_filter_coeffs(cyd, chn, 4095, 0);
#ifdef STEREOOUTPUT
	cyd_set_panning(cyd, chn, CYD_PAN_CENTER);
#endif

	for (int s = 0; s < CYD_SUB_OSCS; ++s)
	{
		chn->subosc[s].random = RANDOM_SEED;
		chn->subosc[s].reg4 = chn->subosc[s].reg5 = chn->subosc[s].reg9 = 1;
	}
	
#ifndef CYD_DISABLE_FM	
	if(chn->fm.flags & CYD_FM_ENABLE_4OP)
	{
		for (int i = 0; i < CYD_FM_NUM_OPS; ++i)
		{
			for (int s = 0; s < CYD_SUB_OSCS; ++s)
			{
				chn->fm.ops[i].subosc[s].random = RANDOM_SEED;
			}
			
			chn->fm.ops[i].pw = 0x400;
		}
	}

	cydfm_init(&chn->fm);
#endif
}

#define EXPONENT 2.718281828459045
#define e_pow_2 7.3890461584 //e ^ 2 since range is [-2; 2]

double map_double(double x, double in_min, double in_max, double out_min, double out_max)
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

static void cyd_init_log_tables(CydEngine *cyd)
{
	for(int i = 0; i < EXP_LUT_SIZE; ++i)
	{
		cyd->lookup_table_exponential[i] = (Uint16)(pow(EXPONENT, map_double(i, 0, EXP_LUT_SIZE, -2, 2)) * 65535.0 / e_pow_2);
	}
	
	for(int i = 1; i < EXP_LUT_SIZE - 1; ++i)
	{
		cyd->lookup_table_exponential[i] = map_Arduino(cyd->lookup_table_exponential[i], cyd->lookup_table_exponential[0], cyd->lookup_table_exponential[EXP_LUT_SIZE - 1], 1, 65535);
	}
	
	cyd->lookup_table_exponential[0] = 0;
	cyd->lookup_table_exponential[EXP_LUT_SIZE - 1] = 65535;
	
	for (int i = 0; i < LUT_SIZE; ++i)
	{
		cyd->lookup_table[i] = i * (i / 2) / ((LUT_SIZE * LUT_SIZE / 65536) / 2);
	}
	
#ifndef CYD_DISABLE_BUZZ
	for (int i = 0; i < YM_LUT_SIZE; ++i)
	{
		static const int ymVolumeTable[16] = { 62, 161, 265, 377, 580, 774, 1155, 1575, 2260, 3088, 4570, 6233, 9330, 13187, 21220, 32767 }; // from leonard's code
		//static const int ymVolumeTable[16] = { 2047, 4095, 6143, 8191, 10239, 12287, 14335, 16383, 18431, 20439, 22527, 24575, 26623, 28671, 30719, 32767 };
		
		cyd->lookup_table_ym[i] = ymVolumeTable[i]; //(Uint32)32767 * (Uint32)(i+1) * (Uint32)(i+1) * (Uint32)(i+1) / (Uint32)(YM_LUT_SIZE * YM_LUT_SIZE * YM_LUT_SIZE);
	}
	
	for (int i = 0; i < YM_LUT_SIZE * 2; ++i)
	{
		static const int AY8930VolumeTable[32] = { 31, 62, 112, 161, 213, 265, 321, 377, 479, 580, 677, 774, 965, 1155, 1365, 1575, 1918, 2260, 2764, 3088, 3829, 4570, 5402, 6233, 7782, 9330, 11259, 13187, 17204, 21220, 26994, 32767 };
		
		cyd->lookup_table_ay8930[i] = AY8930VolumeTable[i];
	}
	
	cyd->lookup_table_ay8930[0] = 0;
	
	cyd->lookup_table_ym[0] = 0;
#endif
	
	const double pi = 3.14159265358979323846;
	
	//initializing sine lookup table
	
	for(int i = 0; i < 16384; ++i)
	{
		double sine = (sin((double)i / 16384.0 / 2.0 * pi) + 1.0) * 32768.0;
		
		Uint16 sine_scaled = (Uint16)sine;
		
		cyd->sine_table[i] = sine_scaled;
		cyd->sine_table[32767 - i] = sine_scaled;
		cyd->sine_table[32768 + i] = (Uint16)(((Sint32)sine_scaled - (Sint32)32768) * (Sint32)(-1) + (Sint32)32768);
		cyd->sine_table[65535 - i] = (Uint16)(((Sint32)sine_scaled - (Sint32)32768) * (Sint32)(-1) + (Sint32)32768);
	}
}

void cyd_set_fm_op_wavetable_offset(CydChannel *chn, Uint16 offset /* 0..0x1000 = 0-100% */, Uint8 i) //if sample is looped, set start offset
{
#ifndef CYD_DISABLE_WAVETABLE
	if (chn->fm.ops[i].wave_entry)
	{
		if(chn->fm.ops[i].wave_entry->flags & CYD_WAVE_LOOP)
		{
			for (int s = 0; s < CYD_SUB_OSCS; ++s)
			{
				chn->fm.ops[i].subosc[s].wave.start_offset = offset * 16;
				
				chn->fm.ops[i].subosc[s].wave.start_point_track_status = (Uint64)chn->fm.ops[i].subosc[s].wave.start_offset * WAVETABLE_RESOLUTION * chn->fm.ops[i].wave_entry->samples / 0x10000;
				
				chn->fm.ops[i].subosc[s].wave.use_start_track_status_offset = true;
			}
		}
		
		else
		{
			for (int s = 0; s < CYD_SUB_OSCS; ++s)
			{
				chn->fm.ops[i].subosc[s].wave.acc = (Uint64)offset * WAVETABLE_RESOLUTION * chn->fm.ops[i].wave_entry->samples / 0x1000;
			}
		}
	}
#endif
}

void cyd_set_wavetable_offset(CydChannel *chn, Uint16 offset /* 0..0x1000 = 0-100% */) //if sample is looped, set start offset
{
#ifndef CYD_DISABLE_WAVETABLE
	if (chn->wave_entry)
	{
		if(chn->wave_entry->flags & CYD_WAVE_LOOP)
		{
			for (int s = 0; s < CYD_SUB_OSCS; ++s)
			{
				chn->subosc[s].wave.start_offset = offset * 16;
				
				chn->subosc[s].wave.start_point_track_status = (Uint64)chn->subosc[s].wave.start_offset * WAVETABLE_RESOLUTION * chn->wave_entry->samples / 0x10000;
				
				chn->subosc[s].wave.use_start_track_status_offset = true;
			}	
		}
		
		else
		{
			for (int s = 0; s < CYD_SUB_OSCS; ++s)
			{
				chn->subosc[s].wave.acc = (Uint64)offset * WAVETABLE_RESOLUTION * chn->wave_entry->samples / 0x1000;
			}
		}
	}
#endif
}

void cyd_set_fm_op_wavetable_end_offset(CydChannel *chn, Uint16 offset /* 0..0x1000 = 0-100% */, Uint8 i) //if sample is looped, set end offset
{
#ifndef CYD_DISABLE_WAVETABLE
	if (chn->fm.ops[i].wave_entry)
	{
		if(chn->fm.ops[i].wave_entry->flags & CYD_WAVE_LOOP)
		{
			for (int s = 0; s < CYD_SUB_OSCS; ++s)
			{
				chn->fm.ops[i].subosc[s].wave.end_offset = (0x10000 - offset * 16) > 0xFFFF ? 0xffff : (0x10000 - offset * 16);
				
				chn->fm.ops[i].subosc[s].wave.end_point_track_status = (Uint64)chn->fm.ops[i].subosc[s].wave.end_offset * WAVETABLE_RESOLUTION * chn->fm.ops[i].wave_entry->samples / 0x10000;
				
				chn->fm.ops[i].subosc[s].wave.use_end_track_status_offset = true;
			}
		}
		
		else
		{
			for (int s = 0; s < CYD_SUB_OSCS; ++s)
			{
				chn->fm.ops[i].subosc[s].wave.acc = (Uint64)offset * WAVETABLE_RESOLUTION * chn->fm.ops[i].wave_entry->samples / 0x1000;
			}
		}
	}
#endif
}

void cyd_set_wavetable_end_offset(CydChannel *chn, Uint16 offset /* 0..0x1000 = 0-100% */) //if sample is looped, set end offset
{
#ifndef CYD_DISABLE_WAVETABLE
	if (chn->wave_entry)
	{
		if(chn->wave_entry->flags & CYD_WAVE_LOOP)
		{
			for (int s = 0; s < CYD_SUB_OSCS; ++s)
			{
				chn->subosc[s].wave.end_offset = (0x10000 - offset * 16) > 0xFFFF ? 0xffff : (0x10000 - offset * 16);
				
				chn->subosc[s].wave.end_point_track_status = (Uint64)chn->subosc[s].wave.end_offset * WAVETABLE_RESOLUTION * chn->wave_entry->samples / 0x10000;
				
				chn->subosc[s].wave.use_end_track_status_offset = true;
			}
		}
	}
#endif
}


void cyd_reset_wavetable(CydEngine *cyd)
{
#ifndef CYD_DISABLE_WAVETABLE
	memset(cyd->wavetable_entries, 0, sizeof(cyd->wavetable_entries[0]) * CYD_WAVE_MAX_ENTRIES);

	for (int i = 0; i < CYD_WAVE_MAX_ENTRIES; ++i)
	{
		cyd_wave_entry_init(&cyd->wavetable_entries[i], NULL, 0, 0, 0, 0, 0);
	}
#endif
}

//from jsSID emulator
void createCombinedWF(Uint16 wfarray[], float bitmul, float bitstrength, float treshold)
{ //I found out how the combined waveform works (neighboring bits affect each other recursively)
	for (int i = 0; i < 4096; i++)
	{
		wfarray[i] = 0; //neighbour-bit strength and DAC MOSFET treshold is approximately set by ears'n'trials

		for (int j = 0; j < 12; j++)
		{
			float bitlevel = 0.0;

			for (int k = 0; k < 12; k++)
			{
				bitlevel += (bitmul / pow(bitstrength, abs(k - j))) * (((i >> k) & 1) - 0.5);
			}

			wfarray[i] += (bitlevel >= treshold) ? pow(2, j) : 0;
		}

		wfarray[i] *= 12;
	}

	for (int i = 0; i < 4096; i++)
	{
		wfarray[i] *= 1.26;
	}
}

long map_Arduino(long x, long in_min, long in_max, long out_min, long out_max)
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; //don't ask me just easiest wavegen+oscview setup involved arduino
}


void cyd_init(CydEngine *cyd, Uint32 sample_rate, int channels)
{
	memset(cyd, 0, sizeof(*cyd));
	
	cyd->sample_rate = sample_rate;
	cyd->lookup_table = malloc(sizeof(*cyd->lookup_table) * LUT_SIZE);
	cyd->oversample = MAX_OVERSAMPLE;
#ifndef CYD_DISABLE_BUZZ
	cyd->lookup_table_ym = malloc(sizeof(*cyd->lookup_table) * YM_LUT_SIZE);
#endif
	
#ifndef USENATIVEAPIS

# ifdef USESDLMUTEXES
	cyd->mutex = SDL_CreateMutex();
# endif

#else

# ifdef WIN32
	InitializeCriticalSection(&cyd->mutex);
	InitializeCriticalSection(&cyd->thread_lock);
# endif

#endif
	
	cyd_init_log_tables(cyd);
	
	createCombinedWF(cyd->PulseSaw_8580, 1.4, 1.9, 0.68); //wasn't there
	createCombinedWF(cyd->PulseTriSaw_8580, 0.8, 2.5, 0.64); 
	createCombinedWF(cyd->TriSaw_8580, 0.8, 2.4, 0.64); 
	
	for (int i = 0; i < CYD_MAX_FX_CHANNELS; ++i)
	{
		cydfx_init(&cyd->fx[i], sample_rate);
	}
#ifndef CYD_DISABLE_WAVETABLE

	cyd->wavetable_entries = calloc(sizeof(cyd->wavetable_entries[0]), CYD_WAVE_MAX_ENTRIES);
	
	cyd_reset_wavetable(cyd);
#endif
	
	cyd_reserve_channels(cyd, channels);
	
	for (int i = 0; i < channels; ++i) //wasn't there
	{
		cyd->channel[i].vol_ksl_mult = 1.0;
		cyd->channel[i].env_ksl_mult = 1.0;
		cyd->channel[i].fm_env_ksl_mult = 1.0;
		cyd->channel[i].fm.fm_vol_ksl_mult = 1.0;
		
		if(cyd->channel[i].fm.flags & CYD_FM_ENABLE_4OP)
		{
			for (int j = 0; j < CYD_FM_NUM_OPS; ++j)
			{
				cyd->channel[i].fm.ops[j].vol_ksl_mult = 1.0;
				cyd->channel[i].fm.ops[j].env_ksl_mult = 1.0;
			}
		}
	}
}


void cyd_set_oversampling(CydEngine *cyd, int oversampling)
{
	cyd->oversample = oversampling;
}


void cyd_reserve_channels(CydEngine *cyd, int channels)
{
	debug("Reserving %d Cyd channels", channels);
	cyd_lock(cyd, 1);

	cyd->n_channels = channels;
	
	if (cyd->n_channels > CYD_MAX_CHANNELS)
	{
		cyd->n_channels = CYD_MAX_CHANNELS;
	}
	
	if (cyd->channel)
	{
		free(cyd->channel);
	}
	
	cyd->channel = calloc(sizeof(*cyd->channel), CYD_MAX_CHANNELS);
	cyd_reset(cyd);
	
	cyd_lock(cyd, 0);
}


void cyd_deinit(CydEngine *cyd)
{
	if (cyd->lookup_table)
	{
		free(cyd->lookup_table);
		cyd->lookup_table = NULL;
	}
	
#ifndef CYD_DISABLE_BUZZ
	if (cyd->lookup_table_ym)	
	{
		free(cyd->lookup_table_ym);
		cyd->lookup_table_ym = NULL;
	}
#endif

	if (cyd->channel)
	{
		free(cyd->channel);
		cyd->channel = NULL;
	}
	
	for (int i = 0; i < CYD_MAX_FX_CHANNELS; ++i)
		cydfx_deinit(&cyd->fx[i]);
	
#ifndef USENATIVEAPIS

# ifdef USESDLMUTEXES
	if (cyd->mutex)
		SDL_DestroyMutex(cyd->mutex);
	cyd->mutex = NULL;
# endif	

#else

# ifdef WIN32
	DeleteCriticalSection(&cyd->mutex);
	DeleteCriticalSection(&cyd->thread_lock);
# endif

#endif

#ifndef CYD_DISABLE_WAVETABLE
	if (cyd->wavetable_entries)
	{
		for (int i = 0; i < CYD_WAVE_MAX_ENTRIES; ++i)
			cyd_wave_entry_deinit(&cyd->wavetable_entries[i]);
			
		free(cyd->wavetable_entries);
		cyd->wavetable_entries = NULL;
	}
#endif
}


void cyd_reset(CydEngine *cyd)
{
	for (int i = 0; i < cyd->n_channels; ++i)
	{
		cyd_init_channel(cyd, &cyd->channel[i]);
		cyd->channel[i].sync_source = i;
	}
}

#define SSG_EG_HLD 1
#define SSG_EG_ALT 2
#define SSG_EG_INV 4
#define SSG_EG_ENABLED 8

#define SSG_EG_SPEED_MULT 6

Uint32 cyd_cycle_fm_op_adsr(const CydEngine *eng, Uint32 flags, Uint32 ym_env_shape, CydFmOpAdsr *adsr, double env_ksl_mult, Uint8 ssg_eg) //SSG-EG variable bits go like this: 0 0 0 0 EN INV ALT HLD
{ //EN means that SSG-EG is enabled; INV means start executing envelope the other way around (start from sustain level, the inversed decay then inversed attack); ALT means that every cycle you
//change direction of envelope execution (normal is atk -> dec -> sus, inverted is sus -> dec -> atk), also means that if there was only one cycle and the bit is 1 you hold the adsr volume not on
//0, but on MAX_SUSTAIN level; HLD means hold, when it is 0 envelope jerk goes forever, when it is 1 you have only one pass

//remember that in SSG-EG mode envelope decay should be executed 6 times faster than in normal mode (http://gendev.spritesmind.net/forum/viewtopic.php?p=5716#5716)
//while attack speed would stay unaffected
#ifndef CYD_DISABLE_ENVELOPE
		// SID style ADSR envelope
		
		if(adsr->passes == 0 && adsr->envelope_state == ATTACK)
		{
			if((ssg_eg & SSG_EG_ENABLED) && (ssg_eg & SSG_EG_INV))
			{
				adsr->envelope_state = DECAY;
				adsr->env_speed = envspd(eng, adsr->d) * SSG_EG_SPEED_MULT;
				adsr->envelope = (1 << 19);
			}
		}

		switch (adsr->envelope_state)
		{
			case SUSTAIN:
			{
				if(ssg_eg & SSG_EG_ENABLED)
				{
					adsr->passes++;
					
					if(!(ssg_eg & SSG_EG_HLD))
					{
						if(!(ssg_eg & SSG_EG_INV))
						{
							if(ssg_eg & SSG_EG_ALT)
							{
								adsr->envelope_state = DECAY;
								adsr->env_speed = envspd(eng, adsr->d) * SSG_EG_SPEED_MULT;
							}
							
							else
							{
								adsr->envelope_state = DECAY;
								adsr->env_speed = envspd(eng, adsr->d) * SSG_EG_SPEED_MULT;
								adsr->envelope = 0xff0000;
							}
						}
						
						else
						{
							if(ssg_eg & SSG_EG_ALT)
							{
								adsr->envelope_state = DECAY;
								adsr->env_speed = envspd(eng, adsr->d) * SSG_EG_SPEED_MULT;
							}
							
							else
							{
								adsr->envelope_state = DECAY;
								adsr->env_speed = envspd(eng, adsr->d) * SSG_EG_SPEED_MULT;
								adsr->envelope = ((Uint32)1 << 19);
							}
						}
					}
					
					else
					{
						if(adsr->passes < 1)
						{
							adsr->envelope_state = DECAY;
							adsr->env_speed = envspd(eng, adsr->d) * SSG_EG_SPEED_MULT;
						}
						
						else
						{
							if(ssg_eg & SSG_EG_ALT)
							{
								adsr->envelope = (ssg_eg & SSG_EG_INV) ? (1 << 19) : (0x1f << 19); return flags; break;
							}
							
							else
							{
								return flags; break;
							}
						}
					}
					
					break;
				}
				
				else
				{
					return flags; break;
				}
			}
			
			case DONE: return flags; break;
			
			case ATTACK:
			if(ssg_eg & SSG_EG_ENABLED)
			{
				if(adsr->envelope < 0xff0000)
				{
					adsr->envelope += adsr->env_speed;
				}
				
				if (adsr->envelope >= 0xff0000) 
				{
					adsr->envelope_state = DECAY;
					adsr->envelope = 0xff0000;

					adsr->env_speed = envspd(eng, adsr->d) * SSG_EG_SPEED_MULT;
				}
			}
			
			else
			{
				if(adsr->envelope < 0xff0000)
				{
					adsr->envelope += adsr->env_speed;
				}
				
				if (adsr->envelope >= 0xff0000) 
				{
					adsr->envelope_state = DECAY;
					adsr->envelope = 0xff0000;

					adsr->env_speed = envspd(eng, adsr->d);
					
					if(env_ksl_mult != 0.0 && env_ksl_mult != 1.0)
					{
						adsr->env_speed = (int)((double)envspd(eng, adsr->d) * env_ksl_mult);
					}
				}
			}
			break;
			
			case DECAY:
			if(ssg_eg & SSG_EG_ENABLED)
			{
				if(!(ssg_eg & SSG_EG_INV))
				{
					if(!(adsr->passes & 1))
					{
						if (adsr->envelope >= (1 << 19) + adsr->env_speed)
						{
							adsr->envelope -= adsr->env_speed;
						}
						
						else
						{
							adsr->envelope = (1 << 19);
							adsr->envelope_state = SUSTAIN;
						}
					}
					
					else
					{
						if (adsr->envelope <= 0xff0000 - adsr->env_speed)
						{
							adsr->envelope += adsr->env_speed;
						}
						
						else
						{
							adsr->envelope = 0xff0000;
							adsr->envelope_state = SUSTAIN;
						}
					}
				}
				
				else
				{
					if(!(adsr->passes & 1))
					{
						if (adsr->envelope <= 0xff0000 - adsr->env_speed)
						{
							adsr->envelope += adsr->env_speed;
						}
						
						else
						{
							adsr->envelope = 0xff0000;
							adsr->envelope_state = SUSTAIN;
						}
					}
					
					else
					{
						if (adsr->envelope >= (1 << 19) + adsr->env_speed)
						{
							adsr->envelope -= adsr->env_speed;
						}
						
						else
						{
							adsr->envelope = (1 << 19);
							adsr->envelope_state = SUSTAIN;
						}
					}
				}
			}
			
			else
			{
				if (adsr->envelope >= ((Uint32)adsr->s << 19) + adsr->env_speed)
				//if (adsr->envelope > ((Uint32)adsr->s << 19) + adsr->env_speed)
				{
					adsr->envelope -= adsr->env_speed;
				}
				
				else
				{
					adsr->envelope = (Uint32)adsr->s << 19;
					adsr->envelope_state = (adsr->s == 0) ? RELEASE : SUSTAIN;
					
					if(env_ksl_mult == 0.0 || env_ksl_mult == 1.0)
					{
						adsr->env_speed = envspd(eng, adsr->r);
					}
					
					else
					{
						adsr->env_speed = (int)((double)envspd(eng, adsr->r) * env_ksl_mult);
					}
				}
			}
			break;
			
			case RELEASE:
				if (adsr->envelope > adsr->env_speed)
				{
					adsr->envelope -= adsr->env_speed;
				}
				
				else 
				{
					adsr->envelope_state = DONE;
					adsr->passes = 0;
					if ((flags & (CYD_FM_OP_ENABLE_WAVE | CYD_FM_OP_WAVE_OVERRIDE_ENV)) != (CYD_FM_OP_ENABLE_WAVE | CYD_FM_OP_WAVE_OVERRIDE_ENV) && !(flags & CYD_FM_OP_ENABLE_CSM_TIMER)) flags &= ~CYD_CHN_ENABLE_GATE;
					adsr->envelope = 0;
				}
				break;
		}
#endif
	
	return flags;
}

Uint32 cyd_cycle_adsr(const CydEngine *eng, Uint32 flags, Uint32 ym_env_shape, CydAdsr *adsr, double env_ksl_mult)
{
	if (!(flags & CYD_CHN_ENABLE_YM_ENV))
	{
#ifndef CYD_DISABLE_ENVELOPE
		// SID style ADSR envelope

		switch (adsr->envelope_state)
		{
			case SUSTAIN:
			case DONE: return flags; break;
			
			case ATTACK:
			
			adsr->envelope += adsr->env_speed;
			
			if (adsr->envelope >= 0xff0000) 
			{
				adsr->envelope_state = DECAY;
				adsr->envelope = 0xff0000;

				adsr->env_speed = envspd(eng, adsr->d);
				
				if(env_ksl_mult != 0.0 || env_ksl_mult != 1.0)
				{
					adsr->env_speed = (int)((double)envspd(eng, adsr->d) * env_ksl_mult);
				}
			}
			
			break;
			
			case DECAY:

				if (adsr->envelope > ((Uint32)adsr->s << 19) + adsr->env_speed)
				{
					adsr->envelope -= adsr->env_speed;
				}
				
				else
				{
					adsr->envelope = (Uint32)adsr->s << 19;
					adsr->envelope_state = (adsr->s == 0) ? RELEASE : SUSTAIN;
					
					if(env_ksl_mult == 0.0 || env_ksl_mult == 1.0)
					{
						adsr->env_speed = envspd(eng, adsr->r);
					}
					
					else
					{
						adsr->env_speed = (int)((double)envspd(eng, adsr->r) * env_ksl_mult);
					}
				}
			
			break;
			
			case RELEASE:
				if (adsr->envelope > adsr->env_speed)
				{
					adsr->envelope -= adsr->env_speed;
				}
				
				else 
				{
					adsr->envelope_state = DONE;
					if ((flags & (CYD_CHN_ENABLE_WAVE | CYD_CHN_WAVE_OVERRIDE_ENV)) != (CYD_CHN_ENABLE_WAVE | CYD_CHN_WAVE_OVERRIDE_ENV)) flags &= ~CYD_CHN_ENABLE_GATE;
					adsr->envelope = 0;
				}
				break;
		}
#endif
	}
	
	else
	{
#ifndef CYD_DISABLE_BUZZ	
		// YM2149 style envelope HOLD is not processed
		
		//if(osc_freq == buzz_freq && osc_acc == 0)
		//{
			//adsr->envelope = 0;
		//}
	
		switch (adsr->envelope_state)
		{
			case ATTACK:
			
				adsr->envelope += adsr->env_speed;
				
				if (adsr->envelope >= YM_LENGTH) 
				{
					if (ym_env_shape & CYD_YM_ENV_ALT)
					{
						adsr->envelope = YM_LENGTH - (adsr->envelope - YM_LENGTH);
						adsr->envelope_state = DECAY;
					}
					
					else
					{
						adsr->envelope &= YM_LENGTH - 1;
						adsr->envelope_state = ATTACK;
					}
				}
			
			break;
			
			case DECAY:
			
				if (adsr->envelope >= adsr->env_speed) 
					adsr->envelope -= adsr->env_speed;
				else
				{
					if (ym_env_shape & CYD_YM_ENV_ALT)
					{
						adsr->envelope = (Uint32)adsr->env_speed - adsr->envelope;
						adsr->envelope_state = ATTACK;
					}
					
					else
					{
						adsr->envelope -= adsr->env_speed;
						adsr->envelope &= YM_LENGTH - 1;
						adsr->envelope_state = DECAY;		
					}
				}
			
			break;
			
			case RELEASE:
				adsr->envelope_state = DONE;
				if ((flags & (CYD_CHN_ENABLE_WAVE|CYD_CHN_WAVE_OVERRIDE_ENV)) != (CYD_CHN_ENABLE_WAVE|CYD_CHN_WAVE_OVERRIDE_ENV)) flags &= ~CYD_CHN_ENABLE_GATE;
				adsr->envelope = 0;
			break;
			
			default: break;
		}
#endif
	}
	
	return flags;
}

#ifndef CYD_DISABLE_LFSR
static void run_lfsrs(CydChannel *chn)
{
	for (int s = 0; s < CYD_SUB_OSCS; ++s)
	{
		shift_lfsr(&chn->subosc[s].reg4, 4, 3);
		shift_lfsr(&chn->subosc[s].reg5, 5, 3);
		
		if (chn->lfsr_type & 8)
		{
			shift_lfsr(&chn->subosc[s].reg9, 9, 5);
		}
		
		else
		{
			shift_lfsr(&chn->subosc[s].reg9, 17, 14);
		}
	}
}
#endif


static void cyd_cycle_channel(CydEngine *cyd, CydChannel *chn)
{
	chn->flags = cyd_cycle_adsr(cyd, chn->flags, chn->ym_env_shape, &chn->adsr, chn->env_ksl_mult);
	
	if (chn->flags & CYD_CHN_ENABLE_WAVE) 
	{
		for (int i = 0; i < CYD_SUB_OSCS; ++i)
		{
			cyd_wave_cycle(&chn->subosc[i].wave, chn->wave_entry);
		}
	}
	
#ifndef CYD_DISABLE_FM
	if (chn->flags & CYD_CHN_ENABLE_FM)
	{
		cydfm_cycle(cyd, &chn->fm);
	}
#endif
	// cycle random lfsr
}


static void cyd_sync_channel(CydEngine *cyd, CydChannel *chn)
{
	if ((chn->flags & CYD_CHN_ENABLE_SYNC) && cyd->channel[chn->sync_source].sync_bit)
	{
		for (int i = 0; i < CYD_SUB_OSCS; ++i)
		{
			chn->subosc[i].wave.acc = 0;
			chn->subosc[i].wave.direction = 0;
			chn->subosc[i].accumulator = 0;
			chn->subosc[i].random = RANDOM_SEED;
			chn->subosc[i].reg4 = 1;
			chn->subosc[i].reg5 = 1;
			chn->subosc[i].reg9 = 1;
			chn->subosc[i].lfsr_ctr = 0;
			
			chn->subosc[i].noise_accumulator = 0;
		}
		
		if(chn->fm.flags & CYD_FM_ENABLE_4OP)
		{
			for(int i = 0; i < CYD_FM_NUM_OPS; ++i)
			{
				if((chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_SYNC) && cyd->channel[chn->fm.ops[i].sync_source].sync_bit)
				{
					for (int s = 0; s < CYD_SUB_OSCS; ++s)
					{
						chn->fm.ops[i].subosc[s].accumulator = 0;
						chn->fm.ops[i].subosc[s].noise_accumulator = 0;
						chn->fm.ops[i].subosc[s].wave.acc = 0;
						chn->fm.ops[i].subosc[s].wave.direction = 0;
						chn->fm.ops[i].subosc[s].random = RANDOM_SEED;
					}
				}
			}
		}
	}
}


static void cyd_advance_oscillators(CydEngine *cyd, CydChannel *chn)
{
	for (int s = 0; s < CYD_SUB_OSCS; ++s)
	{
		Uint32 prev_noise_acc;
		
		Uint32 prev_acc = chn->subosc[s].accumulator;
		chn->subosc[s].accumulator += (Uint32)chn->subosc[s].frequency;
		
		if(chn->flags & CYD_CHN_ENABLE_FIXED_NOISE_PITCH)
		{
			//debug("freq %d noise freq %d", chn->subosc[s].frequency, chn->subosc[s].noise_frequency);
			prev_noise_acc = chn->subosc[s].noise_accumulator;
			chn->subosc[s].noise_accumulator += (Uint32)chn->subosc[s].noise_frequency;
		}
		
		/* only subosc #0 can set the sync bit */
		
		if (s == 0)
			chn->sync_bit |= chn->subosc[s].accumulator & ACC_LENGTH;
		
		if(chn->flags & CYD_CHN_ENABLE_FIXED_NOISE_PITCH)
		{
			chn->subosc[s].noise_accumulator &= ACC_LENGTH - 1;
		}
			
		chn->subosc[s].accumulator &= ACC_LENGTH - 1;
		
		if(chn->flags & CYD_CHN_ENABLE_FIXED_NOISE_PITCH)
		{
			chn->subosc[s].noise_accumulator &= ACC_LENGTH - 1;
		}
		
		if(chn->flags & CYD_CHN_ENABLE_FIXED_NOISE_PITCH)
		{
			if ((prev_noise_acc & (ACC_LENGTH / 32)) != (chn->subosc[s].noise_accumulator & (ACC_LENGTH / 32)))
			{
				if (chn->flags & CYD_CHN_ENABLE_METAL)
				{
					shift_lfsr(&chn->subosc[s].random, 0xe, 8);
					chn->subosc[s].random &= (1 << (0xe + 1)) - 1;
				}
				
				else
				{
					shift_lfsr(&chn->subosc[s].random, 22, 17);
					chn->subosc[s].random &= (1 << (22 + 1)) - 1;
				}
			}
		}
		
		else
		{
			if ((prev_acc & (ACC_LENGTH / 32)) != (chn->subosc[s].accumulator & (ACC_LENGTH / 32)))
			{
				if (chn->flags & CYD_CHN_ENABLE_METAL)
				{
					shift_lfsr(&chn->subosc[s].random, 0xe, 8);
					chn->subosc[s].random &= (1 << (0xe + 1)) - 1;
				}
				
				else
				{
					shift_lfsr(&chn->subosc[s].random, 22, 17);
					chn->subosc[s].random &= (1 << (22 + 1)) - 1;
				}
			}
		}
	
#ifndef CYD_DISABLE_LFSR		
		if (chn->flags & CYD_CHN_ENABLE_LFSR)
		{
			chn->subosc[s].lfsr_acc = (chn->subosc[s].lfsr & 1) ? (WAVE_AMP - 1) : 0;
			
			if (chn->subosc[s].lfsr_ctr >= chn->subosc[s].lfsr_period)
			{
				chn->subosc[s].lfsr_ctr = 0;
			
				switch (chn->lfsr_type & 3)
				{
					case 0: 
						chn->subosc[s].lfsr ^= !!(chn->subosc[s].reg5 & chn->subosc[s].reg9 & 1);
						break;
					
					case 1:
					case 3: 
						chn->subosc[s].lfsr ^= !!(chn->subosc[s].reg5 & 1);
						break;
					
					case 2:
						chn->subosc[s].lfsr ^= !!(chn->subosc[s].reg5 & chn->subosc[s].reg4 & 1);
						break;
						
					case 4: 
						chn->subosc[s].lfsr ^= !!(chn->subosc[s].reg9 & 1);
						break;
						
					case 5: 
					case 7:
						chn->subosc[s].lfsr ^= 1;
						break;
						
					case 6: 
						chn->subosc[s].lfsr ^= !!(chn->subosc[s].reg4 & 1);
						break;
				}
			}
			
			++chn->subosc[s].lfsr_ctr;
			
			run_lfsrs(chn);
		}
#endif
	}
}

//const static Uint32 fbtab1[] = { 0, 64, 32, 16, 8, 4, 2, 1 };
const static Uint32 fbtab1[] = { 0, 384, 256, 128, 96, 64, 48, 32, 24, 16, 12, 8, 6, 4, 3, 2 };

#define MUL 2

static Sint32 harmonic1[16] = { (Sint32)(0.5 * MUL), 1 * MUL, 2 * MUL, 3 * MUL, 4 * MUL, 5 * MUL, 6 * MUL, 7 * MUL, 8 * MUL, 9 * MUL, 10 * MUL, 10 * MUL, 12 * MUL, 12 * MUL, 15 * MUL, 15 * MUL };
static Sint32 harmonicOPN1[16] = { (Sint32)(0.5 * MUL), 1 * MUL, 2 * MUL, 3 * MUL, 4 * MUL, 5 * MUL, 6 * MUL, 7 * MUL, 8 * MUL, 9 * MUL, 10 * MUL, 11 * MUL, 12 * MUL, 13 * MUL, 14 * MUL, 15 * MUL };

static Sint32 cyd_output_fm_ops(CydEngine *cyd, CydChannel *chn, int chan_num, /*channel number*/ Sint32* s /*array of channel outputs*/)
{
	Sint32 ovr[CYD_SUB_OSCS] = { 0 };
	Sint32 o[CYD_FM_NUM_OPS][CYD_SUB_OSCS] = { 0 };
	Sint32 out = 0;
	
	for(int i = 0; i < CYD_FM_NUM_OPS; ++i)
	{
		for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
		{
			ovr[sub] = 0;
		}
		
		if((chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_CSM_TIMER) && chn->fm.ops[i].csm.frequency != 0 && (chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_GATE)) //so when you trigger release it actually stops
		{
			chn->fm.ops[i].csm.accumulator += chn->fm.ops[i].csm.frequency;
			
			if(chn->fm.ops[i].csm.accumulator & ACC_LENGTH) //on every cycle:
			{
				for (int sub = 0; sub < CYD_SUB_OSCS; ++sub) //reset all accumulators
				{
					chn->fm.ops[i].subosc[sub].accumulator = 0;
					chn->fm.ops[i].subosc[sub].noise_accumulator = 0;
					chn->fm.ops[i].subosc[sub].wave.acc = 0;
				}
				
				chn->fm.ops[i].adsr.envelope = 0xff0000; //force envelope into release state, no matter what sustain level is we start from max volume
				chn->fm.ops[i].adsr.envelope_state = RELEASE;
				
				chn->fm.ops[i].adsr.env_speed = envspd(cyd, chn->fm.ops[i].adsr.r);
				
				if(chn->fm.ops[i].env_ksl_mult != 0.0 && chn->fm.ops[i].env_ksl_mult != 1.0)
				{
					chn->fm.ops[i].adsr.env_speed = (int)((double)envspd(cyd, chn->fm.ops[i].adsr.r) * chn->fm.ops[i].env_ksl_mult);
				}
			}
			
			chn->fm.ops[i].csm.accumulator &= ACC_LENGTH - 1;
		}
		
		Uint64 acc, noise_acc, wave_acc[CYD_SUB_OSCS];
		
		chn->fm.ops[i].vol_ksl_mult = chn->fm.ops[i].env_ksl_mult = 1.0;
		
		if((chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) || (chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_ENVELOPE_KEY_SCALING))
		{
			Sint16 vol_ksl_level_final = (chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[i].vol_ksl_level : -1;
			
			chn->fm.ops[i].vol_ksl_mult = (vol_ksl_level_final == -1) ? 1.0 : (pow(((Uint64)get_freq((chn->fm.ops[i].base_note << 8) + chn->fm.ops[i].finetune + chn->fm.ops[i].detune * DETUNE + coarse_detune_table[chn->fm.ops[i].coarse_detune]) / (get_freq(chn->fm.ops[i].freq_for_ksl) + 1.0)), (vol_ksl_level_final == 0 ? 0 : (vol_ksl_level_final / 127.0))));
			//chn->fm.ops[i].vol_ksl_mult = (vol_ksl_level_final == -1) ? 1.0 : (pow((get_freq((chn->fm.ops[i].base_note << 8) + chn->fm.ops[i].finetune + chn->fm.ops[i].detune * 8 + chn->fm.ops[i].coarse_detune * 128) + 1.0) / (get_freq(chn->fm.ops[i].freq_for_ksl) + 1.0), (vol_ksl_level_final == 0 ? 0 : (vol_ksl_level_final / 127.0))));
			
			Sint16 env_ksl_level_final = (chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_ENVELOPE_KEY_SCALING) ? chn->fm.ops[i].env_ksl_level : -1;
			
			chn->fm.ops[i].env_ksl_mult = (env_ksl_level_final == -1) ? 1.0 : (pow(((Uint64)get_freq((chn->fm.ops[i].base_note << 8) + chn->fm.ops[i].finetune + chn->fm.ops[i].detune * DETUNE + coarse_detune_table[chn->fm.ops[i].coarse_detune]) / (get_freq(chn->fm.ops[i].freq_for_ksl) + 1.0)), (env_ksl_level_final == 0 ? 0 : (env_ksl_level_final / 127.0))));
			//chn->fm.ops[i].env_ksl_mult = (env_ksl_level_final == -1) ? 1.0 : (pow((get_freq((chn->fm.ops[i].base_note << 8) + chn->fm.ops[i].finetune + chn->fm.ops[i].detune * 8 + chn->fm.ops[i].coarse_detune * 128) + 1.0) / (get_freq(chn->fm.ops[i].freq_for_ksl) + 1.0), (env_ksl_level_final == 0 ? 0 : (env_ksl_level_final / 127.0))));
			chn->fm.ops[i].env_ksl_mult = 1.0 / chn->fm.ops[i].env_ksl_mult;
		}
		
		chn->fm.ops[i].curr_tremolo = chn->fm.ops[i].tremolo;
		
		if(chn->fm.ops[i].tremolo_interpolation_counter < 171)
		{
			chn->fm.ops[i].curr_tremolo = chn->fm.ops[i].prev_tremolo + (chn->fm.ops[i].tremolo - chn->fm.ops[i].prev_tremolo) * chn->fm.ops[i].tremolo_interpolation_counter / 171;
			chn->fm.ops[i].tremolo_interpolation_counter++;
		}
		
		for (int j = 0; j < (1 << cyd->oversample); ++j)
		{
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				if(chn->fm.ops[i].subosc[sub].frequency != 0)
				{
					if (chn->fm.ops[i].feedback > 0)
					{
						acc = ((Uint64)chn->fm.ops[i].subosc[sub].accumulator + (Uint64)chn->fm.ops[i].mod[sub] + (((Uint64)chn->fm.ops[i].prev[sub] + (Uint64)chn->fm.ops[i].prev2[sub]) / (Uint64)2 + (Uint64)WAVE_AMP / (Uint64)2) * (Uint64)16384 / (Uint64)fbtab1[chn->fm.ops[i].feedback]);
						
						if(chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_FIXED_NOISE_PITCH)
						{
							noise_acc = ((Uint64)chn->fm.ops[i].subosc[sub].noise_accumulator + (Uint64)chn->fm.ops[i].noise_mod[sub] + (((Uint64)chn->fm.ops[i].prev[sub] + (Uint64)chn->fm.ops[i].prev2[sub]) / (Uint64)2 + (Uint64)WAVE_AMP / (Uint64)2) * (Uint64)16384 / (Uint64)fbtab1[chn->fm.ops[i].feedback]);
						}
						
						if ((chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_WAVE) && chn->fm.ops[i].wave_entry) 
						{
							//wave_acc = ((Uint64)chn->fm.ops[i].osc.wave.acc + chn->fm.ops[i].prev * 2048 / fbtab1[chn->fm.ops[i].feedback]) & (ACC_LENGTH - 1); //this worked
							wave_acc[sub] = ((Uint64)chn->fm.ops[i].subosc[sub].wave.acc + (Uint64)chn->fm.ops[i].wave_mod[sub] + (((Uint64)chn->fm.ops[i].prev[sub] + (Uint64)chn->fm.ops[i].prev2[sub]) / (Uint64)2 + (Uint64)WAVE_AMP / (Uint64)2) * (Uint64)16 * ((Uint64)chn->fm.ops[i].wave_entry->loop_end - (Uint64)chn->fm.ops[i].wave_entry->loop_begin) / (Uint64)fbtab1[chn->fm.ops[i].feedback]);
						}
					}
					
					else
					{
						acc = ((Uint64)chn->fm.ops[i].subosc[sub].accumulator + (Uint64)chn->fm.ops[i].mod[sub]);
						noise_acc = ((Uint64)chn->fm.ops[i].subosc[sub].noise_accumulator + (Uint64)chn->fm.ops[i].noise_mod[sub]);
						
						if ((chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_WAVE) && chn->fm.ops[i].wave_entry) 
						{
							wave_acc[sub] = ((Uint64)chn->fm.ops[i].subosc[sub].wave.acc + (Uint64)chn->fm.ops[i].wave_mod[sub]);
						}
					}
					
					Uint64 accumulator = acc;
					ovr[sub] += cyd_osc(chn->fm.ops[i].flags & ~(CYD_CHN_ENABLE_LFSR), accumulator, chn->fm.ops[i].pw, chn->fm.ops[i].subosc[sub].random, 0, chn->fm.ops[i].mixmode, chn->fm.ops[i].sine_acc_shift, cyd) - WAVE_AMP / 2; //ovr += cyd_osc(chn->flags, accumulator % ACC_LENGTH, chn->pw, chn->subosc[sub].random, chn->subosc[sub].lfsr_acc) - WAVE_AMP / 2;
					
					Uint32 prev_noise_acc;
					
					Uint32 prev_acc = acc;
					
					chn->fm.ops[i].subosc[sub].accumulator += (Uint32)chn->fm.ops[i].subosc[sub].frequency;
					chn->fm.ops[i].subosc[sub].accumulator &= ACC_LENGTH - 1;
					
					if(chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_FIXED_NOISE_PITCH)
					{
						prev_noise_acc = chn->fm.ops[i].subosc[sub].noise_accumulator;
						
						chn->fm.ops[i].subosc[sub].noise_accumulator += (Uint32)chn->fm.ops[i].subosc[sub].noise_frequency;
						chn->fm.ops[i].subosc[sub].noise_accumulator &= ACC_LENGTH - 1;
					}
					
					if(chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_FIXED_NOISE_PITCH)
					{
						if ((prev_noise_acc & (ACC_LENGTH / 32)) != (chn->fm.ops[i].subosc[sub].noise_accumulator & (ACC_LENGTH / 32)))
						{
							if (chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_METAL)
							{
								shift_lfsr(&chn->fm.ops[i].subosc[sub].random, 0xe, 8);
								chn->fm.ops[i].subosc[sub].random &= (1 << (0xe + 1)) - 1;
							}
							
							else
							{
								shift_lfsr(&chn->fm.ops[i].subosc[sub].random, 22, 17);
								chn->fm.ops[i].subosc[sub].random &= (1 << (22 + 1)) - 1;
							}
						}
					}
					
					else
					{
						if ((prev_acc & (ACC_LENGTH / 32)) != (chn->fm.ops[i].subosc[sub].accumulator & (ACC_LENGTH / 32)))
						{
							if (chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_METAL)
							{
								shift_lfsr(&chn->fm.ops[i].subosc[sub].random, 0xe, 8);
								chn->fm.ops[i].subosc[sub].random &= (1 << (0xe + 1)) - 1;
							}
							
							else
							{
								shift_lfsr(&chn->fm.ops[i].subosc[sub].random, 22, 17);
								chn->fm.ops[i].subosc[sub].random &= (1 << (22 + 1)) - 1;
							}
						}
					}
				}
			}
		}
		
		for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
		{
			ovr[sub] >>= cyd->oversample;
		}
		
		if ((chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_WAVE) && chn->fm.ops[i].wave_entry->data != NULL && !(chn->fm.ops[i].flags & CYD_FM_OP_WAVE_OVERRIDE_ENV))
		{
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				if (chn->fm.ops[i].subosc[sub].wave.playing && chn->fm.ops[i].subosc[sub].wave.frequency != 0)
				{
					cyd_wave_cycle(&chn->fm.ops[i].subosc[sub].wave, chn->fm.ops[i].wave_entry); //this works
					
					ovr[sub] += cyd_wave_get_sample(&chn->fm.ops[i].subosc[sub].wave, chn->fm.ops[i].wave_entry, (wave_acc[sub]) % ((chn->fm.ops[i].wave_entry->loop_end - chn->fm.ops[i].wave_entry->loop_begin) * WAVETABLE_RESOLUTION)); //this works
				}
			}
		}
		
		chn->fm.ops[i].flags = cyd_cycle_fm_op_adsr(cyd, chn->fm.ops[i].flags, 0, &chn->fm.ops[i].adsr, chn->fm.ops[i].env_ksl_mult, chn->fm.ops[i].ssg_eg_type | (((chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_SSG_EG) ? 1 : 0) << 3));
		
		for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
		{
			o[i][sub] = (Sint32)cyd_fm_op_env_output(cyd, chn->fm.ops[i].flags & ~(CYD_CHN_ENABLE_AY8930_BUZZ_MODE | CYD_CHN_ENABLE_YM_ENV), &chn->fm.ops[i].adsr, ovr[sub]) * (chn->fm.ops[i].curr_tremolo + 512) / 512;
			
			if (chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_RING_MODULATION)
			{
				o[i][sub] = cyd_fm_op_env_output(cyd, chn->fm.ops[i].flags & ~(CYD_CHN_ENABLE_AY8930_BUZZ_MODE | CYD_CHN_ENABLE_YM_ENV), &chn->fm.ops[i].adsr, ovr[sub] * (s[chn->fm.ops[i].ring_mod] + (WAVE_AMP / 2)) / WAVE_AMP) * (chn->fm.ops[i].curr_tremolo + 512) / 512;
			}
			
			if(chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_EXPONENTIAL_VOLUME)
			{
				//o[i] = (Sint32)((double)o[i] * (double)cyd->lookup_table_exponential[chn->fm.ops[i].adsr.volume * 32] / (double)cyd->lookup_table_exponential[4096]);
				
				o[i][sub] = (Sint32)((Sint64)o[i][sub] * (Sint64)cyd->lookup_table_exponential[chn->fm.ops[i].adsr.volume * 32] / (Sint64)cyd->lookup_table_exponential[4096]);
			}
			
			if (chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_FILTER) 
			{
				for(int j = 0; j < two_pow(2, chn->fm.ops[i].flt_slope); ++j)
				{
					cydflt_cycle(&chn->fm.ops[i].flts[j][sub], o[i][sub]);
					
					switch (chn->fm.ops[i].flttype)
					{
						case FLT_BP: o[i][sub] = cydflt_output_bp(&chn->fm.ops[i].flts[j][sub]); break;
						default: case FLT_LP: o[i][sub] = cydflt_output_lp(&chn->fm.ops[i].flts[j][sub]); break;
						case FLT_HP: o[i][sub] = cydflt_output_hp(&chn->fm.ops[i].flts[j][sub]); break; //was only up to there
						
						case FLT_LH: o[i][sub] = (cydflt_output_lp(&chn->fm.ops[i].flts[j][sub]) + cydflt_output_hp(&chn->fm.ops[i].flts[j][sub])) / 2; break;
						case FLT_HB: o[i][sub] = (cydflt_output_hp(&chn->fm.ops[i].flts[j][sub]) + cydflt_output_bp(&chn->fm.ops[i].flts[j][sub])) / 2; break;
						case FLT_LB: o[i][sub] = (cydflt_output_lp(&chn->fm.ops[i].flts[j][sub]) + cydflt_output_bp(&chn->fm.ops[i].flts[j][sub])) / 2; break;
						case FLT_ALL: o[i][sub] = (cydflt_output_lp(&chn->fm.ops[i].flts[j][sub]) + cydflt_output_bp(&chn->fm.ops[i].flts[j][sub]) + cydflt_output_hp(&chn->fm.ops[i].flts[j][sub])) / 3; break;
					}
				}
			}
		}
		
		if(chn->fm.ops[i].feedback > 0)
		{
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[i].prev2[sub] = chn->fm.ops[i].prev[sub];
				chn->fm.ops[i].prev[sub] = o[i][sub] + (WAVE_AMP);
			}
		}
	}
	
	switch(chn->fm.alg)
	{
		case 1:
		default:
		{
			// F  F  F  F
			// 4--3--2--1--(OUT)
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[2].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[2].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[2].wave_entry)
				{
					chn->fm.ops[2].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[2].wave_entry->loop_end - chn->fm.ops[2].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[1].mod[sub] = (Sint64)o[2][sub] * (Sint64)14240;
				chn->fm.ops[1].noise_mod[sub] = (Sint64)o[2][sub] * (Sint64)14240;
				
				if(chn->fm.ops[1].wave_entry)
				{
					chn->fm.ops[1].wave_mod[sub] = (Sint64)o[2][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[1].wave_entry->loop_end - chn->fm.ops[1].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[0].mod[sub] = (Sint64)o[1][sub] * (Sint64)14240;
				chn->fm.ops[0].noise_mod[sub] = (Sint64)o[1][sub] * (Sint64)14240;
				
				if(chn->fm.ops[0].wave_entry)
				{
					chn->fm.ops[0].wave_mod[sub] = (Sint64)o[1][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[0].wave_entry->loop_end - chn->fm.ops[0].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 2:
		{
			// F
			// 4--| F  F
			//    |--2--1--(OUT)
			// F  |
			// 3--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[1].mod[sub] = (Sint64)o[2][sub] * (Sint64)14240 + (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[1].noise_mod[sub] = (Sint64)o[2][sub] * (Sint64)14240 + (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[1].wave_entry)
				{
					chn->fm.ops[1].wave_mod[sub] = ((Sint64)o[2][sub] * (Sint64)3560 + (Sint64)o[3][sub] * (Sint64)3560) * (Sint64)(chn->fm.ops[1].wave_entry->loop_end - chn->fm.ops[1].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[0].mod[sub] = (Sint64)o[1][sub] * (Sint64)14240;
				chn->fm.ops[0].noise_mod[sub] = (Sint64)o[1][sub] * (Sint64)14240;
				
				if(chn->fm.ops[0].wave_entry)
				{
					chn->fm.ops[0].wave_mod[sub] = (Sint64)o[1][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[0].wave_entry->loop_end - chn->fm.ops[0].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 3:
		{
			//    F
			//    4--|  F
			//       |--1--(OUT)
			// F  F  |
			// 3--2--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[2].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[2].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[2].wave_entry)
				{
					chn->fm.ops[2].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[2].wave_entry->loop_end - chn->fm.ops[2].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[0].mod[sub] = (Sint64)o[1][sub] * (Sint64)14240 + (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[0].noise_mod[sub] = (Sint64)o[1][sub] * (Sint64)14240 + (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[0].wave_entry)
				{
					chn->fm.ops[0].wave_mod[sub] = (Sint64)o[1][sub] * (Sint64)3560 + (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[0].wave_entry->loop_end - chn->fm.ops[0].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 4:
		{
			//       F
			//       1--|
			//          |
			// F  F  F  |--(OUT)
			// 4--3--2--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1) + (o[1][0] + o[1][1] + o[1][2]) * ((chn->fm.ops[1].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[1].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[2].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[2].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[2].wave_entry)
				{
					chn->fm.ops[2].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[2].wave_entry->loop_end - chn->fm.ops[2].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[1].mod[sub] = (Sint64)o[2][sub] * (Sint64)14240;
				chn->fm.ops[1].noise_mod[sub] = (Sint64)o[2][sub] * (Sint64)14240;
				
				if(chn->fm.ops[1].wave_entry)
				{
					chn->fm.ops[1].wave_mod[sub] = (Sint64)o[2][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[1].wave_entry->loop_end - chn->fm.ops[1].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 5:
		{
			//          F
			// F  F  |--1--|
			// 4--3--|     |--(OUT) 
			//       |  F  |
			//       |--2--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1) + (o[1][0] + o[1][1] + o[1][2]) * ((chn->fm.ops[1].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[1].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[2].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[2].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[2].wave_entry)
				{
					chn->fm.ops[2].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[2].wave_entry->loop_end - chn->fm.ops[2].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[1].mod[sub] = (Sint64)o[2][sub] * (Sint64)14240;
				chn->fm.ops[1].noise_mod[sub] = (Sint64)o[2][sub] * (Sint64)14240;
				
				if(chn->fm.ops[1].wave_entry)
				{
					chn->fm.ops[1].wave_mod[sub] = (Sint64)o[2][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[1].wave_entry->loop_end - chn->fm.ops[1].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[0].mod[sub] = (Sint64)o[2][sub] * (Sint64)14240;
				chn->fm.ops[0].noise_mod[sub] = (Sint64)o[2][sub] * (Sint64)14240;
				
				if(chn->fm.ops[0].wave_entry)
				{
					chn->fm.ops[0].wave_mod[sub] = (Sint64)o[2][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[0].wave_entry->loop_end - chn->fm.ops[0].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 6:
		{
			// F  F
			// 4--3--|
			//       |--(OUT)
			// F  F  |
			// 2--1--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1) + (o[2][0] + o[2][1] + o[2][2]) * ((chn->fm.ops[2].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[2].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[2].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[2].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[2].wave_entry)
				{
					chn->fm.ops[2].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[2].wave_entry->loop_end - chn->fm.ops[2].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[0].mod[sub] = (Sint64)o[1][sub] * (Sint64)14240;
				chn->fm.ops[0].noise_mod[sub] = (Sint64)o[1][sub] * (Sint64)14240;
				
				if(chn->fm.ops[0].wave_entry)
				{
					chn->fm.ops[0].wave_mod[sub] = (Sint64)o[1][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[0].wave_entry->loop_end - chn->fm.ops[0].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 7:
		{
			// F  
			// 4--|  F
			//    |--2--|
			// F  |     |--(OUT)
			// 3--|  F  |
			//       1--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1) + (o[1][0] + o[1][1] + o[1][2]) * ((chn->fm.ops[1].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[1].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[1].mod[sub] = (Sint64)o[2][sub] * (Sint64)14240 + (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[1].noise_mod[sub] = (Sint64)o[2][sub] * (Sint64)14240 + (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[1].wave_entry)
				{
					chn->fm.ops[1].wave_mod[sub] = ((Sint64)o[2][sub] * (Sint64)3560 + (Sint64)o[3][sub] * (Sint64)3560) * (Sint64)(chn->fm.ops[1].wave_entry->loop_end - chn->fm.ops[1].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 8:
		{
			// F  
			// 4--|
			//    |
			// F  |  F
			// 3--|--1--(OUT)
			//    |
			// F  |
			// 2--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[0].mod[sub] = (Sint64)o[2][sub] * (Sint64)14240 + (Sint64)o[3][sub] * (Sint64)14240 + (Sint64)o[1][sub] * (Sint64)14240;
				chn->fm.ops[0].noise_mod[sub] = (Sint64)o[2][sub] * (Sint64)14240 + (Sint64)o[3][sub] * (Sint64)14240 + (Sint64)o[1][sub] * (Sint64)14240;
				
				if(chn->fm.ops[0].wave_entry)
				{
					chn->fm.ops[0].wave_mod[sub] = ((Sint64)o[2][sub] * (Sint64)3560 + (Sint64)o[3][sub] * (Sint64)3560 + (Sint64)o[1][sub] * (Sint64)3560) * (Sint64)(chn->fm.ops[0].wave_entry->loop_end - chn->fm.ops[0].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 9:
		{
			// F  F
			// 4--3--|
			//       |
			//    F  |
			//    2--|--(OUT)
			//       |
			//    F  |
			//    1--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1) + (o[1][0] + o[1][1] + o[1][2]) * ((chn->fm.ops[1].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[1].vol_ksl_mult : 1) + (o[2][0] + o[2][1] + o[2][2]) * ((chn->fm.ops[2].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[2].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[2].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[2].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[2].wave_entry)
				{
					chn->fm.ops[2].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[2].wave_entry->loop_end - chn->fm.ops[2].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 10:
		{
			//       F
			// F  |--3--|
			// 4--|     |
			//    |  F  |
			//    |--2--|--(OUT)
			//          |
			//       F  |
			//       1--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1) + (o[1][0] + o[1][1] + o[1][2]) * ((chn->fm.ops[1].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[1].vol_ksl_mult : 1) + (o[2][0] + o[2][1] + o[2][2]) * ((chn->fm.ops[2].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[2].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[2].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[2].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[2].wave_entry)
				{
					chn->fm.ops[2].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[2].wave_entry->loop_end - chn->fm.ops[2].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[1].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[1].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[1].wave_entry)
				{
					chn->fm.ops[1].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[1].wave_entry->loop_end - chn->fm.ops[1].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 11:
		{
			//       F
			//    |--3--|
			//    |     |
			// F  |  F  |
			// 4--|--2--|--(OUT)
			//    |     |
			//    |  F  |
			//    |--1--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1) + (o[1][0] + o[1][1] + o[1][2]) * ((chn->fm.ops[1].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[1].vol_ksl_mult : 1) + (o[2][0] + o[2][1] + o[2][2]) * ((chn->fm.ops[2].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[2].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[2].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[2].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[2].wave_entry)
				{
					chn->fm.ops[2].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[2].wave_entry->loop_end - chn->fm.ops[2].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[1].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[1].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[1].wave_entry)
				{
					chn->fm.ops[1].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[1].wave_entry->loop_end - chn->fm.ops[1].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[0].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[0].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[0].wave_entry)
				{
					chn->fm.ops[0].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[0].wave_entry->loop_end - chn->fm.ops[0].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 12:
		{
			//       F
			//    |--3--|
			// F  |     |
			// 4--|  F  |--1--(OUT)
			//    |--2--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1);
			
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				chn->fm.ops[2].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[2].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[2].wave_entry)
				{
					chn->fm.ops[2].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[2].wave_entry->loop_end - chn->fm.ops[2].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[1].mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				chn->fm.ops[1].noise_mod[sub] = (Sint64)o[3][sub] * (Sint64)14240;
				
				if(chn->fm.ops[1].wave_entry)
				{
					chn->fm.ops[1].wave_mod[sub] = (Sint64)o[3][sub] * (Sint64)3560 * (Sint64)(chn->fm.ops[1].wave_entry->loop_end - chn->fm.ops[1].wave_entry->loop_begin) / (Sint64)256;
				}
				
				chn->fm.ops[0].mod[sub] = (Sint64)o[1][sub] * (Sint64)14240 + (Sint64)o[2][sub] * (Sint64)14240;
				chn->fm.ops[0].noise_mod[sub] = (Sint64)o[1][sub] * (Sint64)14240 + (Sint64)o[2][sub] * (Sint64)14240;
				
				if(chn->fm.ops[0].wave_entry)
				{
					chn->fm.ops[0].wave_mod[sub] = ((Sint64)o[1][sub] * (Sint64)3560 + (Sint64)o[2][sub] * (Sint64)3560) * (Sint64)(chn->fm.ops[0].wave_entry->loop_end - chn->fm.ops[0].wave_entry->loop_begin) / (Sint64)256;
				}
			}
			
			break;
		}
		
		case 13:
		{
			// F
			// 4--|
			//    |
			// F  |
			// 3--|
			//    |
			// F  |--(OUT)
			// 2--|
			//    |
			// F  |
			// 1--|
			
			out = (o[0][0] + o[0][1] + o[0][2]) * ((chn->fm.ops[0].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[0].vol_ksl_mult : 1) + (o[1][0] + o[1][1] + o[1][2]) * ((chn->fm.ops[1].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[1].vol_ksl_mult : 1) + (o[2][0] + o[2][1] + o[2][2]) * ((chn->fm.ops[2].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[2].vol_ksl_mult : 1) + (o[3][0] + o[3][1] + o[3][2]) * ((chn->fm.ops[3].flags & CYD_FM_OP_ENABLE_VOLUME_KEY_SCALING) ? chn->fm.ops[3].vol_ksl_mult : 1);
			
			break;
		}
	}
	
	return out;
}


static Sint32 cyd_output_channel(CydEngine *cyd, CydChannel *chn)
{
	Sint32 ovr = 0;
	
	chn->sync_bit = 0;

#ifndef CYD_DISABLE_FM	
	const Uint32 mod = (chn->flags & CYD_CHN_ENABLE_FM) ? cydfm_modulate(cyd, &chn->fm, 0) : 0;
#endif
	
	for (int i = 0; i < (1 << cyd->oversample); ++i)
	{
		for (int s = 0; s < CYD_SUB_OSCS; ++s)
		{
			if (chn->subosc[s].frequency != 0)
			{
#ifdef CYD_DISABLE_FM
				Uint32 accumulator = chn->subosc[s].accumulator;
#else
				Uint32 accumulator;
				
				if ((chn->fm.flags & CYD_FM_ENABLE_ADDITIVE))
				{
					accumulator = chn->subosc[s].accumulator;
				}
				
				else
				{
					accumulator = chn->subosc[s].accumulator + mod;
				}
#endif
				ovr += cyd_osc(chn->flags, accumulator & (ACC_LENGTH - 1), chn->pw, chn->subosc[s].random, chn->subosc[s].lfsr_acc, chn->mixmode, chn->sine_acc_shift, cyd) - WAVE_AMP / 2; //ovr += cyd_osc(chn->flags, accumulator % ACC_LENGTH, chn->pw, chn->subosc[s].random, chn->subosc[s].lfsr_acc) - WAVE_AMP / 2;
			}
		}
		
		cyd_advance_oscillators(cyd, chn); // Need to move the oscillators per every oversample subcycle
		
#ifndef CYD_DISABLE_FM
		cydfm_cycle_oversample(cyd, &chn->fm);
#endif
	}
	
	return (ovr >> cyd->oversample);
}

Sint32 cyd_fm_op_env_output(const CydEngine *cyd, Uint32 chn_flags, const CydFmOpAdsr *adsr, Sint32 input)
{
#ifndef CYD_DISABLE_ENVELOPE
	if (adsr->envelope_state == ATTACK)
	{
		if(chn_flags & CYD_FM_OP_ENABLE_EXPONENTIAL_ATTACK)
		{                                                                                                                                                                                //                                _
			return ((Sint64)input * (65535 - cyd->lookup_table_exponential[(65535 - (adsr->envelope / 0x800) - 1) & (EXP_LUT_SIZE - 1)])) / 65536 * (Sint32)(adsr->volume) / MAX_VOLUME; //so attack goes curvy like this /
		} //EXP_LUT_SIZE
		
		else
		{
			return ((Sint64)input * ((Sint32)adsr->envelope / 0x10000) / 256) * (Sint32)(adsr->volume) / MAX_VOLUME;
		}
	}
	
	if (adsr->envelope_state == DECAY)
	{
		if(chn_flags & CYD_FM_OP_ENABLE_EXPONENTIAL_DECAY)
		{
			Sint64 out = ((Sint64)input * (cyd->lookup_table_exponential[(Uint32)((((double)adsr->envelope - (double)0xff0000) * (double)32 / ((double)32 - (double)adsr->s) / (double)0x800) - (double)1) & (EXP_LUT_SIZE - 1)])) / 65536 * (Sint32)(adsr->volume) / MAX_VOLUME;// * (32 - adsr->s) / 32; //so decay (and release below) go curvy like this  \_
			return (Sint64)((double)out * (double)(cyd->lookup_table[1023] - cyd->lookup_table[adsr->s * 32]) / (double)cyd->lookup_table[1023]) + (Sint64)((double)((Sint64)input * (Sint32)(adsr->volume) / MAX_VOLUME) * (double)cyd->lookup_table[adsr->s * 32] / (double)cyd->lookup_table[1023]);
		}
		
		else
		{
			return ((Sint64)input * (cyd->lookup_table[(adsr->envelope / (65536 * 256 / LUT_SIZE)) & (LUT_SIZE - 1)]) / 65536) * (Sint32)(adsr->volume) / MAX_VOLUME;
		}
	}
	
	if (adsr->envelope_state == RELEASE)
	{
		if(chn_flags & CYD_FM_OP_ENABLE_EXPONENTIAL_RELEASE)
		{
			Sint64 out = ((Sint64)input * (cyd->lookup_table_exponential[(Uint32)((((double)adsr->envelope - (double)(adsr->s << 19)) * (double)32 / ((double)adsr->s) / (double)0x800) - (double)1) & (EXP_LUT_SIZE - 1)])) / 65536 * (Sint32)(adsr->volume) / MAX_VOLUME;
			return (Sint64)((double)out * (double)(cyd->lookup_table[adsr->s * 32]) / (double)cyd->lookup_table[1023]);
		}
		
		else
		{
			return ((Sint64)input * (cyd->lookup_table[(adsr->envelope / (65536 * 256 / LUT_SIZE)) & (LUT_SIZE - 1)]) / 65536) * (Sint32)(adsr->volume) / MAX_VOLUME;
		}
	}
	
	else
	{
		return ((Sint64)input * (cyd->lookup_table[(adsr->envelope / (65536 * 256 / LUT_SIZE)) & (LUT_SIZE - 1)]) / 65536) * (Sint32)(adsr->volume) / MAX_VOLUME;
	}
#else
	return input * (Sint32)(adsr->volume) / MAX_VOLUME;
#endif
}


Sint32 cyd_env_output(const CydEngine *cyd, Uint32 chn_flags, const CydAdsr *adsr, Sint32 input)
{
	if (chn_flags & CYD_CHN_ENABLE_YM_ENV)
	{
#ifndef CYD_DISABLE_BUZZ
		if(chn_flags & CYD_CHN_ENABLE_AY8930_BUZZ_MODE)
		{
			int idx = adsr->envelope * (Uint32)YM_LUT_SIZE * 2 / YM_LENGTH;
			return input * cyd->lookup_table_ay8930[idx & (YM_LUT_SIZE * 2 - 1)] / 32768 * (Sint32)(adsr->volume) / MAX_VOLUME;
		}
		
		else
		{
			int idx = adsr->envelope * (Uint32)YM_LUT_SIZE / YM_LENGTH;
			return input * cyd->lookup_table_ym[idx & (YM_LUT_SIZE - 1)] / 32768 * (Sint32)(adsr->volume) / MAX_VOLUME;
		}
#else
		return input * (Sint32)(adsr->volume) / MAX_VOLUME;
#endif
	}
	
	else
	{
#ifndef CYD_DISABLE_ENVELOPE
		
		if (adsr->envelope_state == ATTACK)
		{
			if(chn_flags & CYD_CHN_ENABLE_EXPONENTIAL_ATTACK)
			{                                                                                                                                                                                //                                _
				return ((Sint64)input * (65535 - cyd->lookup_table_exponential[(65535 - (adsr->envelope / 0x800) - 1) & (EXP_LUT_SIZE - 1)])) / 65536 * (Sint32)(adsr->volume) / MAX_VOLUME; //so attack goes curvy like this /
			} //EXP_LUT_SIZE
			
			else
			{
				return ((Sint64)input * ((Sint32)adsr->envelope / 0x10000) / 256) * (Sint32)(adsr->volume) / MAX_VOLUME;
			}
		}
		
		if (adsr->envelope_state == DECAY)
		{
			if(chn_flags & CYD_CHN_ENABLE_EXPONENTIAL_DECAY)
			{
				Sint64 out = ((Sint64)input * (cyd->lookup_table_exponential[(Uint32)((((double)adsr->envelope - (double)0xff0000) * (double)32 / ((double)32 - (double)adsr->s) / (double)0x800) - (double)1) & (EXP_LUT_SIZE - 1)])) / 65536 * (Sint32)(adsr->volume) / MAX_VOLUME;// * (32 - adsr->s) / 32; //so decay (and release below) go curvy like this  \_
				return (Sint64)((double)out * (double)(cyd->lookup_table[1023] - cyd->lookup_table[adsr->s * 32]) / (double)cyd->lookup_table[1023]) + (Sint64)((double)((Sint64)input * (Sint32)(adsr->volume) / MAX_VOLUME) * (double)cyd->lookup_table[adsr->s * 32] / (double)cyd->lookup_table[1023]);
			}
			
			else
			{
				return ((Sint64)input * (cyd->lookup_table[(adsr->envelope / (65536 * 256 / LUT_SIZE)) & (LUT_SIZE - 1)]) / 65536) * (Sint32)(adsr->volume) / MAX_VOLUME;
			}
		}
		
		if (adsr->envelope_state == RELEASE)
		{
			if(chn_flags & CYD_CHN_ENABLE_EXPONENTIAL_RELEASE)
			{
				Sint64 out = ((Sint64)input * (cyd->lookup_table_exponential[(Uint32)((((double)adsr->envelope - (double)(adsr->s << 19)) * (double)32 / ((double)adsr->s) / (double)0x800) - (double)1) & (EXP_LUT_SIZE - 1)])) / 65536 * (Sint32)(adsr->volume) / MAX_VOLUME;
				return (Sint64)((double)out * (double)(cyd->lookup_table[adsr->s * 32]) / (double)cyd->lookup_table[1023]);
			}
			
			else
			{
				return ((Sint64)input * (cyd->lookup_table[(adsr->envelope / (65536 * 256 / LUT_SIZE)) & (LUT_SIZE - 1)]) / 65536) * (Sint32)(adsr->volume) / MAX_VOLUME;
			}
		}
		
		else
		{
			return ((Sint64)input * (cyd->lookup_table[(adsr->envelope / (65536 * 256 / LUT_SIZE)) & (LUT_SIZE - 1)]) / 65536) * (Sint32)(adsr->volume) / MAX_VOLUME;
		}
#else
		return input * (Sint32)(adsr->volume) / MAX_VOLUME;
#endif
	}
}


#ifdef STEREOOUTPUT
static void cyd_output(CydEngine *cyd, Sint32 *left, Sint32 *right)
#else
static Sint32 cyd_output(CydEngine *cyd)
#endif
{
#ifdef STEREOOUTPUT
	*left = *right = 0;
	Sint32 fx_l[CYD_MAX_FX_CHANNELS] = {0}, fx_r[CYD_MAX_FX_CHANNELS] = {0};
#else
	Sint32 v = 0, fx_input[CYD_MAX_FX_CHANNELS] = {0};
#endif
	Sint32 s[CYD_MAX_CHANNELS];
	
	for (int i = 0; i < cyd->n_channels; ++i)
	{
		s[i] = (Sint32)cyd_output_channel(cyd, &cyd->channel[i]);
#ifndef CYD_DISABLE_WAVETABLE
		if ((cyd->channel[i].flags & CYD_CHN_ENABLE_WAVE) && cyd->channel[i].wave_entry && !(cyd->channel[i].flags & CYD_CHN_WAVE_OVERRIDE_ENV))
		{
			for (int sub = 0; sub < CYD_SUB_OSCS; ++sub)
			{
				if (cyd->channel[i].subosc[sub].wave.playing && cyd->channel[i].subosc[sub].wave.frequency != 0)
				{
#ifdef CYD_DISABLE_FM
					CydWaveAcc accumulator = cyd->channel[i].subosc[sub].wave.acc;
#else
					CydWaveAcc accumulator;
				
					if ((cyd->channel[i].fm.flags & CYD_FM_ENABLE_ADDITIVE) && (cyd->channel[i].flags & CYD_CHN_ENABLE_FM))
					{
						accumulator = cyd->channel[i].subosc[sub].wave.acc;
					}
					
					else
					{
						accumulator = (cyd->channel[i].flags & CYD_CHN_ENABLE_FM) ? cydfm_modulate_wave(cyd, &cyd->channel[i].fm, cyd->channel[i].wave_entry, cyd->channel[i].subosc[sub].wave.acc) : cyd->channel[i].subosc[sub].wave.acc;
					}	
#endif				
					if ((cyd->channel[i].fm.flags & CYD_FM_ENABLE_ADDITIVE) && (cyd->channel[i].flags & CYD_CHN_ENABLE_FM))
					{
						//s[i] += cyd_wave_get_sample(&cyd->channel[i].subosc[sub].wave, cyd->channel[i].wave_entry, accumulator) + (cyd->channel[i].fm.current_modulation) * 64 - 65536 * 64;
						s[i] += cyd_wave_get_sample(&cyd->channel[i].subosc[sub].wave, cyd->channel[i].wave_entry, accumulator);
					}
					
					else
					{
						s[i] += cyd_wave_get_sample(&cyd->channel[i].subosc[sub].wave, cyd->channel[i].wave_entry, accumulator);
					}		
				}
			}
		}
#endif
	}
	
	for (int i = 0; i < cyd->n_channels; ++i)
	{
		CydChannel *chn = &cyd->channel[i];
		
		chn->vol_ksl_mult = 1.0;
		chn->env_ksl_mult = 1.0;
		
		if(chn->fm.flags & CYD_FM_ENABLE_4OP)
		{
			for(int i = 0; i < CYD_FM_NUM_OPS; ++i)
			{
				chn->fm.ops[i].vol_ksl_mult = 1.0;
				chn->fm.ops[i].env_ksl_mult = 1.0;
			}
		}
		
		if((chn->flags & CYD_CHN_ENABLE_VOLUME_KEY_SCALING) || (chn->flags & CYD_CHN_ENABLE_ENVELOPE_KEY_SCALING))
		{
			Sint16 vol_ksl_level_final = (chn->flags & CYD_CHN_ENABLE_VOLUME_KEY_SCALING) ? chn->vol_ksl_level : -1;
			
			chn->vol_ksl_mult = (vol_ksl_level_final == -1) ? 1.0 : (pow((get_freq((chn->base_note << 8) + chn->finetune) + 1.0) / (get_freq(chn->freq_for_ksl) + 1.0), (vol_ksl_level_final == 0 ? 0 : (vol_ksl_level_final / 127.0))));
			
			Sint16 env_ksl_level_final = (chn->flags & CYD_CHN_ENABLE_ENVELOPE_KEY_SCALING) ? chn->env_ksl_level : -1;
			
			chn->env_ksl_mult = (env_ksl_level_final == -1) ? 1.0 : (pow((get_freq((chn->base_note << 8) + chn->finetune) + 1.0) / (get_freq(chn->freq_for_ksl) + 1.0), (env_ksl_level_final == 0 ? 0 : (env_ksl_level_final / 127.0))));
			chn->env_ksl_mult = 1.0 / chn->env_ksl_mult;
		}
		
		Sint32 o = 0;
		
#ifndef CYD_DISABLE_FM
		if ((chn->flags & CYD_CHN_ENABLE_GATE) || ((cyd->channel[i].flags & CYD_CHN_ENABLE_FM) && cyd->channel[i].fm.adsr.envelope > 0) || ((cyd->channel[i].fm.flags & CYD_FM_ENABLE_4OP) && (cyd->channel[i].fm.ops[0].adsr.envelope > 0 || cyd->channel[i].fm.ops[1].adsr.envelope > 0 || cyd->channel[i].fm.ops[2].adsr.envelope > 0 || cyd->channel[i].fm.ops[3].adsr.envelope > 0 || (cyd->channel[i].fm.ops[0].flags & CYD_FM_OP_ENABLE_GATE) || (cyd->channel[i].fm.ops[1].flags & CYD_FM_OP_ENABLE_GATE) || (cyd->channel[i].fm.ops[2].flags & CYD_FM_OP_ENABLE_GATE) || (cyd->channel[i].fm.ops[3].flags & CYD_FM_OP_ENABLE_GATE))))// || (cyd->channel[i].fm.flags & CYD_FM_ENABLE_GATE)) //now no flag for fm gate
#else
		if (chn->flags & CYD_CHN_ENABLE_GATE)
#endif
		{
			chn->curr_tremolo = chn->tremolo;
			
			if(chn->tremolo_interpolation_counter < 171)
			{
				chn->curr_tremolo = chn->prev_tremolo + (chn->tremolo - chn->prev_tremolo) * chn->tremolo_interpolation_counter / 171;
				chn->tremolo_interpolation_counter++;
			}
			
#ifndef CYD_DISABLE_FM

			if(cyd->channel[i].flags & CYD_CHN_ENABLE_FM)
			{
				chn->fm.fm_curr_tremolo = chn->fm.fm_tremolo;
				
				if(chn->fm.fm_tremolo_interpolation_counter < 171)
				{
					chn->fm.fm_curr_tremolo = chn->fm.fm_prev_tremolo + (chn->fm.fm_tremolo - chn->fm.fm_prev_tremolo) * chn->fm.fm_tremolo_interpolation_counter / 171;
					chn->fm.fm_tremolo_interpolation_counter++;
				}
			}
#endif
			o = (Sint32)cyd_env_output(cyd, chn->flags, &chn->adsr, s[i]) * (cyd->channel[i].curr_tremolo + 512) / 512 * ((chn->flags & CYD_CHN_ENABLE_VOLUME_KEY_SCALING) ? chn->vol_ksl_mult : 1);
			
			if (chn->flags & CYD_CHN_ENABLE_RING_MODULATION)
			{
				o = cyd_env_output(cyd, chn->flags, &chn->adsr, s[i] * (s[chn->ring_mod] + (WAVE_AMP / 2)) / WAVE_AMP) * (cyd->channel[i].curr_tremolo + 512) / 512 * ((chn->flags & CYD_CHN_ENABLE_VOLUME_KEY_SCALING) ? chn->vol_ksl_mult : 1);
			}
			
			if(chn->flags & CYD_CHN_ENABLE_EXPONENTIAL_VOLUME)
			{
				o = (Sint32)((Sint64)o * (Sint64)cyd->lookup_table_exponential[chn->adsr.volume * 32] / (Sint64)cyd->lookup_table_exponential[4096]);
			}
			
#ifndef CYD_DISABLE_FM

			if ((cyd->channel[i].fm.flags & CYD_FM_ENABLE_ADDITIVE) && (cyd->channel[i].flags & CYD_CHN_ENABLE_FM)) //new additive fm 2-op design
			{
				if(cyd->channel[i].fm.flags & CYD_FM_ENABLE_WAVE)
				{
					if(cyd->channel[i].fm.current_modulation != 0) //to avoid clicks
					{
						o += ((cyd->channel[i].fm.current_modulation) * 32 - 65536 * 32);
					}
				}
			}
			
			if((cyd->channel[i].fm.flags & CYD_FM_ENABLE_4OP) && !(cyd->channel[i].fm.flags & CYD_FM_FOUROP_BYPASS_MAIN_INST_FILTER))
			{
				o += cyd_output_fm_ops(cyd, chn, i, s) * (Sint32)cyd->channel[i].fm.fm_4op_vol / MAX_VOLUME;
			}
#endif

#ifndef CYD_DISABLE_WAVETABLE			
			if ((cyd->channel[i].flags & CYD_CHN_ENABLE_WAVE) && cyd->channel[i].wave_entry && (cyd->channel[i].flags & CYD_CHN_WAVE_OVERRIDE_ENV))
			{
				for (int s = 0; s < CYD_SUB_OSCS; ++s)
				{
					if (cyd->channel[i].subosc[s].wave.playing && cyd->channel[i].subosc[s].wave.frequency != 0)
					{
#ifdef CYD_DISABLE_FM
						CydWaveAcc accumulator = cyd->channel[i].subosc[s].wave.acc;
#else
						CydWaveAcc accumulator;
						
						accumulator = (cyd->channel[i].flags & CYD_CHN_ENABLE_FM) ? cydfm_modulate_wave(cyd, &cyd->channel[i].fm, cyd->channel[i].wave_entry, cyd->channel[i].subosc[s].wave.acc) : cyd->channel[i].subosc[s].wave.acc;
						
						if ((cyd->channel[i].fm.flags & CYD_FM_ENABLE_ADDITIVE) && (cyd->channel[i].flags & CYD_CHN_ENABLE_FM))
						{
							accumulator = cyd->channel[i].subosc[s].wave.acc;
						}				
#endif	
						o += cyd_wave_get_sample(&cyd->channel[i].subosc[s].wave, chn->wave_entry, accumulator) * (Sint32)(chn->adsr.volume) / MAX_VOLUME;
					}
				}
			}
#endif		
			
#ifndef CYD_DISABLE_FILTER
			if (chn->flags & CYD_CHN_ENABLE_FILTER) 
			{
				for(int i = 0; i < two_pow(2, chn->flt_slope); i++)
				{
					cydflt_cycle(&chn->flts[i], o);
				
					switch (chn->flttype)
					{
						case FLT_BP: o = cydflt_output_bp(&chn->flts[i]); break;
						default: case FLT_LP: o = cydflt_output_lp(&chn->flts[i]); break;
						case FLT_HP: o = cydflt_output_hp(&chn->flts[i]); break; //was only up to there
						
						case FLT_LH: o = (cydflt_output_lp(&chn->flts[i]) + cydflt_output_hp(&chn->flts[i])) / 2; break;
						case FLT_HB: o = (cydflt_output_hp(&chn->flts[i]) + cydflt_output_bp(&chn->flts[i])) / 2; break;
						case FLT_LB: o = (cydflt_output_lp(&chn->flts[i]) + cydflt_output_bp(&chn->flts[i])) / 2; break;
						case FLT_ALL: o = (cydflt_output_lp(&chn->flts[i]) + cydflt_output_bp(&chn->flts[i]) + cydflt_output_hp(&chn->flts[i])) / 3; break;
					}
				}
			}
#endif
			
			if((cyd->channel[i].fm.flags & CYD_FM_ENABLE_4OP) && (cyd->channel[i].fm.flags & CYD_FM_FOUROP_BYPASS_MAIN_INST_FILTER))
			{
				o += cyd_output_fm_ops(cyd, chn, i, s) * (int)cyd->channel[i].fm.fm_4op_vol / MAX_VOLUME;
			}
			
#ifdef STEREOOUTPUT
			Sint32 ol = o * chn->gain_left / CYD_STEREO_GAIN, or = o * chn->gain_right / CYD_STEREO_GAIN;
#endif		

			if (chn->flags & CYD_CHN_ENABLE_FX)
			{
#ifdef STEREOOUTPUT
				fx_l[chn->fx_bus] += ol;
				fx_r[chn->fx_bus] += or;
#else
				fx_input[chn->fx_bus] += o;
#endif
			}
			
			else
			{
#ifdef STEREOOUTPUT
				*left += ol;
				*right += or;
#else
				v += o;
#endif		
			}
		}
		
#ifndef STANDALONE_COMPILE
		
		if(mused.flags2 & SHOW_OSCILLOSCOPES_PATTERN_EDITOR) //oscilloscopes in patterns
		{
			mused.channels_output_buffers[i][mused.channels_output_buffer_counters[i]] = o;
			mused.channels_output_buffer_counters[i]++;
			
			if(mused.channels_output_buffer_counters[i] >= 8192)
			{
				mused.channels_output_buffer_counters[i] = 0;
			}
		}
#endif
	}
	
	for (int i = 0; i < CYD_MAX_FX_CHANNELS; ++i)
	{
#ifdef STEREOOUTPUT
		Sint32 l, r;
		cydfx_output(&cyd->fx[i], fx_l[i], fx_r[i], &l, &r);
		*left += l;
		*right += r;
#else
		v += cydfx_output(&cyd->fx[i], fx_input[i]);
#endif
	}
	
#ifndef STEREOOUTPUT
	return v;
#endif
}


static void cyd_cycle(CydEngine *cyd)
{
	for (int i = 0; i < cyd->n_channels; ++i)
	{
		cyd_cycle_channel(cyd, &cyd->channel[i]);
	}
	
	for (int i = 0; i < cyd->n_channels; ++i)
	{
		cyd_sync_channel(cyd, &cyd->channel[i]);
	}
}


#ifdef NOSDL_MIXER
void cyd_output_buffer(void *udata, Uint8 *_stream, int len)
#else
void cyd_output_buffer(int chan, void *_stream, int len, void *udata)
#endif
{
	CydEngine *cyd = udata;
	Sint16 * stream = (void*)_stream;
	cyd->samples_output = 0;
	
	for (int i = 0; i < len; i += sizeof(Sint16), ++stream, ++cyd->samples_output)
	{
	
#ifndef USENATIVEAPIS

#ifndef USESDLMUTEXES
#ifdef DEBUG
		Uint32 waittime = SDL_GetTicks();
#endif
		while (cyd->lock_request) 
		{
#ifdef DEBUG
			if (SDL_GetTicks() - waittime > 5000)
			{
				warning("Deadlock from cyd_output_buffer");
				waittime = SDL_GetTicks();
			}
#endif
			SDL_Delay(1);
		}
#endif

#endif
	
		if (cyd->flags & CYD_PAUSED) 
		{ 
			i += BUFFER_GRANULARITY * 2 * sizeof(Sint16); 
			stream += BUFFER_GRANULARITY * 2;
			continue; 
		}
		
		cyd_lock(cyd, 1);
		
		for (int g = 0; g < BUFFER_GRANULARITY && i < len; i += sizeof(Sint16)*2, stream += 2, ++cyd->samples_output)
		{
		
			if (cyd->callback && cyd->callback_counter-- == 0)
			{
				cyd->callback_counter = cyd->callback_period-1;
				if (!cyd->callback(cyd->callback_parameter))
				{
					cyd_lock(cyd, 0);
					return;
				}
			}
			
#ifdef STEREOOUTPUT
			Sint32 output, left, right;
			cyd_output(cyd, &left, &right);
			output = (left + right) / 2;
#else
			Sint32 output = cyd_output(cyd);
#endif

#ifdef NOSDL_MIXER
			Sint32 o = (output * PRE_GAIN) / PRE_GAIN_DIVISOR;
#else
			Sint32 o = (Sint32)*(Sint16*)stream + (output * PRE_GAIN) / PRE_GAIN_DIVISOR;
#endif
			
			if (o < -32768) o = -32768;
			else if (o > 32767) o = 32767;
			
			*(Sint16*)stream = o;
			
			cyd_cycle(cyd);
		}

		cyd_lock(cyd, 0);
	}
}


#ifdef NOSDL_MIXER
void cyd_output_buffer_stereo(void *udata, Uint8 *_stream, int len)
#else
void cyd_output_buffer_stereo(int chan, void *_stream, int len, void *udata)
#endif
{
	CydEngine *cyd = udata;
	Sint16 *stream = (void*)_stream;
	cyd->samples_output = 0;
	cyd->flags &= ~CYD_CLIPPING;
	
	for (int i = 0; i < len; )
	{
#ifndef USENATIVEAPIS
	
#ifndef USESDLMUTEXES
#ifdef DEBUG
		Uint32 waittime = SDL_GetTicks();
#endif
		while (cyd->lock_request) 
		{
#ifdef DEBUG
			if (SDL_GetTicks() - waittime > 5000)
			{
				warning("Deadlock from cyd_output_buffer");
				waittime = SDL_GetTicks();
			}
#endif
			SDL_Delay(1);
		}
#endif

#endif
	
		if (cyd->flags & CYD_PAUSED) 
		{ 
			i += BUFFER_GRANULARITY * 2 * sizeof(Sint16); 
			stream += BUFFER_GRANULARITY * 2;
			continue; 
		}
		
		cyd_lock(cyd, 1);
		
		Sint32 o1, o2; //wasn't there
		
		for (int g = 0; g < BUFFER_GRANULARITY && i < len; i += sizeof(Sint16)*2, stream += 2, ++cyd->samples_output)
		{
			if (cyd->callback && cyd->callback_counter-- == 0)
			{
				cyd->callback_counter = cyd->callback_period-1;
				if (!cyd->callback(cyd->callback_parameter))
				{
					cyd_lock(cyd, 0);
					return;
				}
			}

			Sint32 left, right;
#ifdef STEREOOUTPUT
			cyd_output(cyd, &left, &right);
#else
			left = right = cyd_output(cyd);
#endif

#ifdef NOSDL_MIXER
			o1 = (left * PRE_GAIN) / PRE_GAIN_DIVISOR;
#else
			o1 = (Sint32)*(Sint16*)stream + (left * PRE_GAIN) / PRE_GAIN_DIVISOR;
#endif
			
			if (o1 < -32768) 
			{
				o1 = -32768;
				cyd->flags |= CYD_CLIPPING;
			}
			
			else if (o1 > 32767) 
			{
				o1 = 32767;
				cyd->flags |= CYD_CLIPPING;
			}
			
			*(Sint16*)stream = o1;

#ifdef NOSDL_MIXER
			o2 = (right * PRE_GAIN) / PRE_GAIN_DIVISOR;
#else
			o2 = (Sint32)*((Sint16*)stream + 1) + (right * PRE_GAIN) / PRE_GAIN_DIVISOR;
#endif
			
			if (o2 < -32768)
			{
				o2 = -32768;
				cyd->flags |= CYD_CLIPPING;
			}
			
			else if (o2 > 32767)
			{
				o2 = 32767;
				cyd->flags |= CYD_CLIPPING;
			}
			
			*((Sint16*)stream + 1) = o2;
			
			cyd_cycle(cyd);
			++cyd->samples_played;
			
#ifndef STANDALONE_COMPILE

			if(mused.flags & SHOW_OSCILLOSCOPE_INST_EDITOR)
			{
				mused.output_buffer[mused.output_buffer_counter] = (o1 + o2) / 2;
				mused.output_buffer_counter++;
				
				if(mused.output_buffer_counter >= 8192)
				{
					mused.output_buffer_counter = 0;
				}
			}
#endif
		}
		
		cyd_lock(cyd, 0);
	}
}


void cyd_set_frequency(CydEngine *cyd, CydChannel *chn, int subosc, Uint32 frequency)
{
	if (frequency != 0)
	{
		chn->subosc[subosc].frequency = (Uint64)(ACC_LENGTH >> (cyd->oversample)) / (Uint64)1024 * (Uint64)(frequency) / (Uint64)cyd->sample_rate;

#ifndef CYD_DISABLE_LFSR	
		chn->subosc[subosc].lfsr_period = (Uint64)cyd->sample_rate * (Uint64)1024 / frequency;
#endif
	}
	else
		chn->subosc[subosc].frequency = 0;
	
#ifndef CYD_DISABLE_FM
	if (subosc == 0)
	{
		cydfm_set_frequency(cyd, &chn->fm, frequency);
		chn->true_freq = frequency;
	}
#endif
}


void cyd_set_wavetable_frequency(CydEngine *cyd, CydChannel *chn, int subosc, Uint32 frequency)
{	
#ifndef CYD_DISABLE_WAVETABLE
	if (frequency != 0 && chn->wave_entry)
	{
		chn->subosc[subosc].wave.frequency = (Uint64)WAVETABLE_RESOLUTION * (Uint64)chn->wave_entry->sample_rate / (Uint64)cyd->sample_rate * (Uint64)frequency / (Uint64)get_freq(chn->wave_entry->base_note);
	}

	else
	{
		chn->subosc[subosc].wave.playing = false;
		chn->subosc[subosc].wave.frequency = 0;
	}
#endif
}


void cyd_set_env_frequency(CydEngine *cyd, CydChannel *chn, Uint32 frequency)
{
#ifndef CYD_DISABLE_BUZZ
	chn->subosc[0].buzz_detune_freq = frequency;
	
	chn->adsr.env_speed = (Uint64)YM_LENGTH / (Uint64)1024 * (Uint64)frequency / (Uint64)cyd->sample_rate;
#endif
}


void cyd_set_env_shape(CydChannel *chn, Uint8 shape)
{
#ifndef CYD_DISABLE_BUZZ
	chn->ym_env_shape = shape;
	
	if ((chn->flags & CYD_CHN_ENABLE_KEY_SYNC) || (chn->adsr.envelope_state == DONE || chn->adsr.envelope_state == SUSTAIN))
	{
		if (shape & CYD_YM_ENV_ATT)
		{
			chn->adsr.envelope = 0;
			chn->adsr.envelope_state = ATTACK;
		}
		else
		{
			chn->adsr.envelope = YM_LENGTH;
			chn->adsr.envelope_state = DECAY;
		}
	}
#endif
}


void cyd_enable_gate(CydEngine *cyd, CydChannel *chn, Uint8 enable)
{
	if (enable)
	{
		if (!(chn->flags & CYD_CHN_ENABLE_YM_ENV))
		{
#ifndef CYD_DISABLE_ENVELOPE
			chn->adsr.envelope_state = ATTACK;
			chn->adsr.envelope = 0x0;
			
			//chn->adsr.env_speed = envspd(cyd, chn->adsr.a);
			
			chn->adsr.env_speed = envspd(cyd, chn->adsr.a);
					
			if(chn->env_ksl_mult != 0.0 && chn->env_ksl_mult != 1.0)
			{
				chn->adsr.env_speed = (int)((double)envspd(cyd, chn->adsr.a) * chn->env_ksl_mult);
			}
			//chn->adsr.env_speed = (int)((double)envspd(cyd, chn->adsr.a) * chn->env_ksl_mult);
			
			chn->flags = cyd_cycle_adsr(cyd, chn->flags, chn->ym_env_shape, &chn->adsr, chn->env_ksl_mult);
#ifndef CYD_DISABLE_FM	
			chn->fm.adsr.envelope_state = ATTACK;
			chn->fm.adsr.envelope = chn->fm.attack_start << 19;
			//chn->fm.adsr.env_speed = envspd(cyd, chn->fm.adsr.a);
			
			chn->fm.adsr.env_speed = (int)((double)envspd(cyd, chn->fm.adsr.a) * (chn->fm.fm_env_ksl_mult == 0.0 ? 1 : chn->fm.fm_env_ksl_mult));
			cyd_cycle_adsr(cyd, 0, 0, &chn->fm.adsr, chn->fm.fm_env_ksl_mult);
#endif
#endif
		}
		
		if(chn->fm.flags & CYD_FM_ENABLE_4OP)
		{
			for(int i = 0; i < CYD_FM_NUM_OPS; ++i)
			{
				if(chn->fm.ops[i].trigger_delay == 0)
				{
					chn->fm.ops[i].adsr.envelope_state = ATTACK;
					chn->fm.ops[i].adsr.envelope = 0x0;
					
					chn->fm.ops[i].adsr.env_speed = envspd(cyd, chn->fm.ops[i].adsr.a);
					
					if(chn->fm.ops[i].env_ksl_mult != 0.0 && chn->fm.ops[i].env_ksl_mult != 1.0)
					{
						chn->fm.ops[i].adsr.env_speed = (int)((double)envspd(cyd, chn->fm.ops[i].adsr.a) * chn->fm.ops[i].env_ksl_mult);
					}
					
					//cyd_cycle_adsr(cyd, 0, 0, &chn->fm.ops[i].adsr, chn->fm.ops[i].env_ksl_mult);
					cyd_cycle_fm_op_adsr(cyd, 0, 0, &chn->fm.ops[i].adsr, chn->fm.ops[i].env_ksl_mult, chn->fm.ops[i].ssg_eg_type | (((chn->fm.ops[i].flags & CYD_FM_OP_ENABLE_SSG_EG) ? 1 : 0) << 3));
					
					//chn->fm.ops[i].trigger_delay--;
				}
			}
		}
		
		if (chn->flags & CYD_CHN_ENABLE_KEY_SYNC)
		{
			for (int s = 0; s < CYD_SUB_OSCS; ++s)
			{
				chn->subosc[s].accumulator = 0;
				
				chn->subosc[s].noise_accumulator = 0;
				chn->subosc[s].wave.acc = 0;
				
				chn->subosc[s].reg4 = chn->subosc[s].reg5 = chn->subosc[s].reg9 = 1;
				chn->subosc[s].lfsr_ctr = 0;
			}
			
#ifndef CYD_DISABLE_FM
			chn->fm.accumulator = 0;
			chn->fm.wave.acc = 0;
			
			if(chn->fm.flags & CYD_FM_ENABLE_4OP)
			{
				for(int i = 0; i < CYD_FM_NUM_OPS; ++i)
				{
					if(chn->fm.ops[i].trigger_delay == 0)
					{
						for (int s = 0; s < CYD_SUB_OSCS; ++s)
						{
							chn->fm.ops[i].subosc[s].accumulator = 0;
							chn->fm.ops[i].subosc[s].noise_accumulator = 0;
							chn->fm.ops[i].subosc[s].wave.acc = 0;
						}
						
						chn->fm.ops[i].flags |= CYD_FM_OP_ENABLE_GATE;
						
						chn->fm.ops[i].trigger_delay--;
					}
					
					else
					{
						for (int s = 0; s < CYD_SUB_OSCS; ++s)
						{
							chn->fm.ops[i].subosc[s].accumulator = 0;
							chn->fm.ops[i].subosc[s].noise_accumulator = 0;
							chn->fm.ops[i].subosc[s].wave.acc = 0;
						}
					}
				}
			}
#endif
		}
		
		chn->flags |= CYD_CHN_ENABLE_GATE;
	}
	
	else
	{
		chn->flags &= ~CYD_CHN_WAVE_OVERRIDE_ENV;
		chn->adsr.envelope_state = RELEASE;
		
		//chn->adsr.env_speed = (int)((double)envspd(cyd, chn->adsr.r) * chn->env_ksl_mult);

		chn->adsr.env_speed = envspd(cyd, chn->adsr.r);

		if(chn->env_ksl_mult != 0.0 && chn->env_ksl_mult != 1.0)
		{
			chn->adsr.env_speed = (int)((double)envspd(cyd, chn->adsr.r) * chn->env_ksl_mult);
		}
		
		//chn->adsr.env_speed = envspd(cyd, chn->adsr.r);
		
#ifndef CYD_DISABLE_FM
		chn->fm.adsr.envelope_state = RELEASE;
		//chn->fm.adsr.env_speed = envspd(cyd, chn->fm.adsr.r);
		chn->fm.adsr.env_speed = (int)((double)envspd(cyd, chn->fm.adsr.r) * (chn->fm.fm_env_ksl_mult == 0.0 ? 1 : chn->fm.fm_env_ksl_mult));
		
		if(chn->fm.flags & CYD_FM_ENABLE_4OP)
		{
			for(int i = 0; i < CYD_FM_NUM_OPS; ++i)
			{
				chn->fm.ops[i].flags &= ~CYD_FM_OP_WAVE_OVERRIDE_ENV;
				chn->fm.ops[i].adsr.envelope_state = RELEASE;
				
				chn->fm.ops[i].flags &= ~CYD_FM_OP_ENABLE_GATE;
				
				chn->fm.ops[i].adsr.env_speed = envspd(cyd, chn->fm.ops[i].adsr.r);
				
				if(chn->fm.ops[i].env_ksl_mult != 0.0 && chn->fm.ops[i].env_ksl_mult != 1.0)
				{
					chn->fm.ops[i].adsr.env_speed = (int)((double)envspd(cyd, chn->fm.ops[i].adsr.r) * chn->fm.ops[i].env_ksl_mult);
				}
			}
		}
#endif		
	}
}


void cyd_set_waveform(CydChannel *chn, Uint32 wave)
{
	chn->flags = ((Uint32)chn->flags & (Uint32)(~WAVEFORMS)) | ((Uint32)wave & (Uint32)WAVEFORMS);
}


void cyd_set_callback(CydEngine *cyd, int (*callback)(void*), void*param, Uint16 period)
{
	cyd_lock(cyd, 1);

	cyd->samples_played	= 0;
	cyd->callback_parameter = param;
	cyd->callback = callback;
	cyd->callback_period = cyd->sample_rate / period;
	cyd->callback_counter = cyd->callback_counter % cyd->callback_period;
	
	cyd_lock(cyd, 0);
}


void cyd_set_callback_rate(CydEngine *cyd, Uint16 period)
{
	cyd_lock(cyd, 1);
	
	cyd->callback_period = cyd->sample_rate / period;
	cyd->callback_counter = cyd->callback_counter % cyd->callback_period;
	
	cyd_lock(cyd, 0);
}


#ifdef USENATIVEAPIS
# ifdef WIN32

static void fill_buffer(CydEngine *cyd)
{
	//waveOutUnprepareHeader(cyd->hWaveOut, &cyd->waveout_hdr[cyd->waveout_hdr_idx],sizeof(WAVEHDR));

#ifdef NOSDL_MIXER
	cyd_output_buffer_stereo(cyd, cyd->waveout_hdr[cyd->waveout_hdr_idx].lpData, cyd->waveout_hdr[cyd->waveout_hdr_idx].dwBufferLength);
#else
	cyd_output_buffer_stereo(0, cyd->waveout_hdr[cyd->waveout_hdr_idx].lpData, cyd->waveout_hdr[cyd->waveout_hdr_idx].dwBufferLength, cyd);
#endif
	
	//waveOutPrepareHeader(cyd->hWaveOut, &cyd->waveout_hdr[cyd->waveout_hdr_idx],sizeof(WAVEHDR));
	
	cyd->waveout_hdr[cyd->waveout_hdr_idx].dwFlags = WHDR_PREPARED;
	
	if (waveOutWrite(cyd->hWaveOut, &cyd->waveout_hdr[cyd->waveout_hdr_idx], sizeof(cyd->waveout_hdr[cyd->waveout_hdr_idx])) != MMSYSERR_NOERROR)
		warning("waveOutWrite returned error");
	
	if (++cyd->waveout_hdr_idx >= CYD_NUM_WO_BUFFERS)
		cyd->waveout_hdr_idx = 0;
}


static DWORD WINAPI ThreadProc(void *param)
{
	CydEngine *cyd = param;
	
	for(;;)
	{
		EnterCriticalSection(&cyd->thread_lock);
		
		if (!cyd->thread_running)
		{
			LeaveCriticalSection(&cyd->thread_lock);
			break;
		}
		
		while (cyd->buffers_available > 0)
		{
			LeaveCriticalSection(&cyd->thread_lock);
			fill_buffer(cyd);
			EnterCriticalSection(&cyd->thread_lock);
			--cyd->buffers_available;
			
		}
		
		LeaveCriticalSection(&cyd->thread_lock);
		
		Sleep(1);
	}
	
	debug("Thread exit");
	
	return 0;
}


static DWORD WINAPI waveOutProc(void *param)
{
	CydEngine *cyd = (void*)param;
	MSG msg;
	
	while (GetMessage(&msg, 0, 0, 0) == 1)
	{
		if (msg.message == MM_WOM_DONE)
		{
			EnterCriticalSection(&cyd->thread_lock);
			
			++cyd->buffers_available;
			
			LeaveCriticalSection(&cyd->thread_lock);
		}
		
		if (msg.message == MM_WOM_CLOSE)
		{
			break;
		}
	}
	
	return 0;
}

# endif
#endif


#ifdef NOSDL_MIXER
int cyd_register(CydEngine * cyd, int buffer_length)
#else
int cyd_register(CydEngine * cyd)
#endif
{
#ifndef USENATIVEAPIS
# ifndef NOSDL_MIXER
	int frequency, channels;
	Uint16 format;
	if (Mix_QuerySpec(&frequency, &format, &channels))
	{
		switch (format)
		{
			case AUDIO_S16SYS:
			break;
			
			default:
			return 0;
			break;
		}
	
		switch (channels)
		{
			case 1: if (!Mix_RegisterEffect(MIX_CHANNEL_POST, cyd_output_buffer, NULL, cyd)) return 0; break;
			case 2: if (!Mix_RegisterEffect(MIX_CHANNEL_POST, cyd_output_buffer_stereo, NULL, cyd)) return 0; break;
			default: return 0; break;
		}
		
		return 1;
	}
	else return 0;
# else

	SDL_AudioSpec desired, obtained;

	/* 22050Hz - FM Radio quality */
	desired.freq = cyd->sample_rate;

	/* 16-bit signed audio */
	desired.format = AUDIO_S16SYS;

	/* Stereo */
	desired.channels = 2;

	/* Large audio buffer reduces risk of dropouts but increases response time */
	desired.samples = buffer_length;

	/* Our callback function */
	desired.callback = cyd_output_buffer_stereo;
	desired.userdata = cyd;

	debug("Opening SDL audio");
	
	/* Open the audio device */
	if (SDL_OpenAudio(&desired, &obtained) < 0)
	{
		warning("Could not open audio device");
		return 0;
	}
	
	debug("Got %d Hz/format %d/%d channels", obtained.freq, obtained.format, obtained.channels);
	
	SDL_PauseAudio(0);
	
	return 1;
# endif
#else

# ifdef WIN32
	WAVEFORMATEX waveformat;
	waveformat.cbSize = 0;
	waveformat.wFormatTag = WAVE_FORMAT_PCM;
    waveformat.wBitsPerSample = 16;
	waveformat.nChannels = 2;
    waveformat.nSamplesPerSec = cyd->sample_rate;
	waveformat.nBlockAlign = waveformat.nChannels * waveformat.wBitsPerSample / 8;
    waveformat.nAvgBytesPerSec = waveformat.nSamplesPerSec * waveformat.nBlockAlign;
	
	CreateThread(NULL, 0, waveOutProc, cyd, 0, &cyd->cb_handle);
	
	MMRESULT result = waveOutOpen(&cyd->hWaveOut, 0, &waveformat, cyd->cb_handle, (DWORD)cyd, CALLBACK_THREAD);
	
	if (result != MMSYSERR_NOERROR)
	{
		warning("waveOutOpen failed (%x)", result);
		return 0;
	}
	
	for (int i = 0; i < CYD_NUM_WO_BUFFERS; ++i)
	{
		WAVEHDR * h = &cyd->waveout_hdr[i];
		
		ZeroMemory(h, sizeof(*h));
		
		h->dwBufferLength = CYD_NUM_WO_BUFFER_SIZE * 2 * sizeof(Sint16);
		h->lpData = calloc(h->dwBufferLength, 1);
		
		waveOutPrepareHeader(cyd->hWaveOut, &cyd->waveout_hdr[i],sizeof(WAVEHDR));
	}
	
	cyd->buffers_available = CYD_NUM_WO_BUFFERS;
	cyd->thread_running = 1;
	
	CreateThread(NULL, 0, ThreadProc, cyd, 0, &cyd->thread_handle);
	SetThreadPriority((HANDLE)cyd->thread_handle, THREAD_PRIORITY_HIGHEST);
	
	return 1;
# else

# error Platform not supported for native apis

# endif

	return 0;
#endif
}


int cyd_unregister(CydEngine * cyd)
{
	debug("cyd_unregister");	
#ifndef USENATIVEAPIS
# ifndef NOSDL_MIXER
	int frequency, channels;
	Uint16 format;
	if (Mix_QuerySpec(&frequency, &format, &channels))
	{
		switch (channels)
		{
			case 1: if (!Mix_UnregisterEffect(MIX_CHANNEL_POST, cyd_output_buffer)) return 0; break;
			case 2: if (!Mix_UnregisterEffect(MIX_CHANNEL_POST, cyd_output_buffer_stereo)) return 0; break;
			default: return 0; break;
		}
		
		cyd_lock(cyd, 1);
		cyd_lock(cyd, 0);
		
		return 1;
	}
	else return 0;
# else

	debug("Waiting for stuff");	
	cyd_lock(cyd, 1);
	debug("Done waiting");	
	cyd_lock(cyd, 0);
	
	debug("Closing audio");	
	SDL_CloseAudio();
	debug("SDL_CloseAudio finished");	
	
	return 1;
# endif
#else

	cyd_pause(cyd, 0);

	debug("Waiting for thread");
	cyd_lock(cyd, 1);
	cyd->thread_running = 0;
	cyd_lock(cyd, 0);
	WaitForSingleObject((HANDLE)cyd->thread_handle, 2000);
	
	waveOutReset(cyd->hWaveOut);

	for (int i = 0; i < CYD_NUM_WO_BUFFERS; ++i)
	{
		if (cyd->waveout_hdr[i].dwFlags & WHDR_PREPARED)
			waveOutUnprepareHeader(cyd->hWaveOut, &cyd->waveout_hdr[i], sizeof(cyd->waveout_hdr[i]));
		free(cyd->waveout_hdr[i].lpData);
	}

	waveOutClose(cyd->hWaveOut);
	
	WaitForSingleObject((HANDLE)cyd->cb_handle, 2000);
		
	return 1;
#endif
}


void cyd_set_filter_coeffs(CydEngine * cyd, CydChannel *chn, Uint16 cutoff, Uint8 resonance)
{
#ifndef CYD_DISABLE_FILTER
	//static const Uint16 resonance_table[] = {10, 512, 1300, 2300, 2400, 2500, 2600, 2700, 2800, 2900, 3000, 3100, 3200, 3300, 3400, 4500}; //was {10, 512, 1300, 1950}
	for(int i = 0; i < (int)pow(2, chn->flt_slope); i++)
	{
		cydflt_set_coeff(&chn->flts[i], cutoff, resonance, cyd->sample_rate);
	}
#endif
}


void cyd_lock(CydEngine *cyd, Uint8 enable)
{
	if (cyd->flags & CYD_SINGLE_THREAD) return; // For export, mainly

#ifndef USENATIVEAPIS

#ifndef USESDLMUTEXES
	if (enable)
	{
#ifdef DEBUG
		Uint32 waittime = SDL_GetTicks();
#endif
		cyd->lock_request = 1;
		while (cyd->lock_locked )
		{
#ifdef DEBUG
			if (SDL_GetTicks() - waittime > 5000)
			{
				warning("Deadlock from cyd_lock");
				waittime = SDL_GetTicks();
			}
#endif
			SDL_Delay(1);
		}
	}
	else
	{
		cyd->lock_request = 0;
		while (cyd->lock_locked)
		{
			SDL_Delay(1);
		}
	}	
#else	
	if (enable)
	{
		SDL_LockMutex(cyd->mutex);
	}
	
	else
	{
		SDL_UnlockMutex(cyd->mutex);
	}
#endif
#else

# ifdef WIN32
	if (enable)
	{
		EnterCriticalSection(&cyd->mutex);
	}
	
	else
	{
		LeaveCriticalSection(&cyd->mutex);
	}
# endif

#endif
}


#ifdef STEREOOUTPUT
void cyd_set_panning(CydEngine *cyd, CydChannel *chn, Uint8 panning)
{
	if (chn->panning == panning) return;
	
	chn->panning = my_min(CYD_PAN_RIGHT, my_max(CYD_PAN_LEFT, panning));
	float a = M_PI / 2 * (float)(chn->panning - CYD_PAN_LEFT) / (CYD_PAN_RIGHT - CYD_PAN_LEFT);
	chn->gain_left = cos(a) * CYD_STEREO_GAIN;
	chn->gain_right = sin(a) * CYD_STEREO_GAIN;
}
#endif


void cyd_set_wave_entry(CydChannel *chn, const CydWavetableEntry * entry)
{
	chn->wave_entry = entry;
	
	for (int s = 0; s < CYD_SUB_OSCS; ++s)
	{
		chn->subosc[s].wave.playing = true;
		chn->subosc[s].wave.acc = 0;
		chn->subosc[s].wave.frequency = 0;
		chn->subosc[s].wave.direction = 0;
	}
}

void cyd_pause(CydEngine *cyd, Uint8 enable)
{
#ifdef USENATIVEAPIS
#ifdef WIN32


	if (enable)
		waveOutPause(cyd->hWaveOut);
	else
		waveOutRestart(cyd->hWaveOut);
#endif
#else
	cyd_lock(cyd, 1);
	
	if (enable)
		cyd->flags |= CYD_PAUSED;
	else
		cyd->flags &= ~CYD_PAUSED;
	
	cyd_lock(cyd, 0);
#endif
}
